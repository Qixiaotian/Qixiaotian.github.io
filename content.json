{"meta":{"title":null,"subtitle":null,"description":"smile everyDay","author":null,"url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Ie兼容性问题","slug":"ie兼容性问题","date":"2020-11-23T12:46:25.000Z","updated":"2020-11-23T07:36:30.727Z","comments":true,"path":"2020/11/23/ie兼容性问题/","link":"","permalink":"http://example.com/2020/11/23/ie%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 浏览器兼容是一件很头疼的事，其中又属 ie8 现在整理一下常遇到的问题和解决方式，后期会陆续更新。。。 js 涉及的统计一下： IE8 兼容 console.log 1234567window.console = window.console || (function () &#123; var c = &#123;&#125;; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = function () &#123;&#125;; return c; &#125;)(); String.trim () 方法，去除空格事件不能够兼容 iE8,9 12345if (!String.prototype.trim) &#123; String.prototype.trim = function trim() &#123; return this.replace(/^\\s+|\\s+$/g, &quot;&quot;); &#125;;&#125; oninput,onchange,onpropertychange oninput 事件 ：当前对象属性发生改变，都会触发事件（非 ie） onpropertychange ：是 ie 版本 在 input 中，如果想捕获用户的键盘输入，用 onkeyup 检查事件就可以了，但是 onkeyup 并不支持复制和粘贴，因此需要动态监测 textarea 中值的变化，这就需要 onpropertychange（用在 IE 浏览器）和 oninput（非 IE 浏览器）结合在一起使用: 123Ev.on(ele, &quot;input propertychange&quot;, function (e) &#123; // do something&#125;); placeholder https://github.com/mathiasbynens/jquery-placeholder IE8 下不支持 HTML5 属性 placeholder，不过为解决此问题的 js 插件挺多的，比如：jquery-placeholder。 在谷歌浏览器中点击事件 onclick 默认会触发 onmouseout 和 onmouseleave 123if (event.relatedTarget != null) &#123; //doSomeThing()&#125; 该属性不支持 IE, 但 ie 不会出现谷歌这种情况 2. Css 涉及的统计一下： ie 不兼容 border-radius 1234-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;behavior: url(&#x27;../lib/PIE-1.0.0/PIE.htc&#x27;); /*引用PIE.htc文件的路径*/ text-overflow 文本溢出 1234overflow: hidden;white-space: nowrap;-o-text-overflow: ellipsis; /* for Opera */text-overflow: ellipsis; /* for IE */ 3. 不兼容 line-height 1234567line-height: 32px;line-height: 32px\\9; /*IE8*/*line-height: 32px; /* IE7支持 */_line-height: 32px; /* IE6支持 */-ms-line-height: 32px; /*IE9+支持*/-webkit-line-height: 32px; /*chrome safair*/-moz-line-height: 32px; /*火狐*/ 兼容 html5 标签和 css3 的一些属性 html5shiv.js、html5media.js、respond.js modernizr（一款兼容 css3、html5 等元素的插件） box-shadow 12345/**filter:--低于ie8的--*/-ms-filter: &quot;progid:DXImageTransform.Microsoft.Shadow(color=#CCCCCC,direction=0,strength=6) progid:DXImageTransform.Microsoft.Shadow(color=#CCCCCC,direction=90,strength=6) progid:DXImageTransform.Microsoft.Shadow(color=#CCCCCC,direction=180,strength=6) progid:DXImageTransform.Microsoft.Shadow(color=#CCCCCC,direction=270,strength=6)&quot;; rgba () 和 opacity: opacity：不能实现元素透明文字不透明的效果 12opacity: 0.5;/** ie： filter:Alpha(opacity=x) */ rgba ：实现元素透明文字不透明的效果 12background: rgba(255, 255, 255, 0.1);filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);","categories":[],"tags":[{"name":"about","slug":"about","permalink":"http://example.com/tags/about/"}]},{"title":"Ajax运行原理","slug":"Ajax运行机制","date":"2020-11-23T07:42:00.000Z","updated":"2020-11-23T07:42:10.188Z","comments":true,"path":"2020/11/23/Ajax运行机制/","link":"","permalink":"http://example.com/2020/11/23/Ajax%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"# AJAX # 服务器与客户端 # 服务器（server） 我们如果想把自己的网页，让其它人能够访问，就必须要用到服务器的知识了。 # 作用 服务器是一个非常重要的概念，做为一名前端人员，我们在实现的工作过程可能不会直接与服务器打交道，但是，我们应该理解所有的应用都需要有服务器的支持。 比如：生活中我们也会听到服务器这三个字。 （一台服务器服务于多台设备） 简单来理解： 服务器 = 硬件配置高的电脑 + 安装特殊软件 是提供服务的机器。给其它设备（电脑，手机，平板…）提供某种特殊服务的电脑 # 服务器的分类 简单来理解： 服务器 = 硬件配置高的电脑 + 安装特殊软件 安装的软件不同，它能提供的服务也不同。 根据所能提供的服务不同，可分成很多种： web 服务器： 安装了能提供 web服务 的软件。如 iis, nginx, apache 等。 ftp……: 上传文件 # 客户端（client) 客户端：连接到服务器，享受服务的设备，就是客户端。 # 访问 web 服务器的基本流程 # 商场买电脑的过程 商场买东西 1. 定位商场的地址 2. 到商场，告诉专卖店你的需要 3. 给你电脑 4. 回家使用电脑 # 访问 web 服务器 （请求响应流程示意图） 基本流程 确认地址。用户在浏览器（客户端）地址栏输入要访问的网站网址（URL） 发送请求。浏览器向服务器发送请求 (request)，告知服务器要获取的内容 获取响应。服务端收到浏览器发送的请求，并把处理的结果返回给浏览器 (response) 显示内容。浏览器将服务端返回的结果显示到界面上 # 本地虚拟 web 服务器 为了方便学习，我们会在自己的电脑上安装服务器软件，把自己的电脑虚拟成服务器。换句话说，我们的电脑既是客户端，又是服务器。 我们需要提供 web 服务：让其它同学能够访问我们网页。 web 服务器 = 硬件配置高的电脑 + web 软件（如 iis,apache, nginx） 方法： 安装特殊的 web 软件：iis apache nginx 安装 vscode 的插件 live-server 安装 Teseve 使用第三方的集成软件 app_server, phpStudy 等 使用黑盒工具app.exe 其它任何一种方法都可以把你的电脑虚拟成服务器，让其它同学来访问。 # 介绍黑盒服务器 参见具体的文档。 启动软件 注意观察端口号。以 3005 为例。 访问网页 先准备文件。把网页放在 public 文件夹下。 访问： 方法一：http://localhost:3005/index.html 方法二：http:// 本机 ip/index.html 访问数据 行话也称为接口。get 类型的接口可以直接在浏览器中观看效果。 # AJAX 技术的好处 总结如下两点好处： 局部更新，提升用户体验，提升性能。 分离开发，提高开发效率。在项目实际开发过程中，ajax 是一个必不可少的技术，是前后端分离开发的基础。 后端同学提供接口。这个接口我们可以理解是一个 函数 ：它的内部进行业务处理，数据库访问等等操作，并返回结果。如何去实现这函数的功能就是后端同学的任务了。 前端同学调用接口获取数据（有其特定的格式），然后再把数据转化成的图文并茂的网页。 # 通过 network 面板来观察 AJAX 掌握： network 面板 all / xhr response # ajax 是什么 AJAX ，全称是：Asynchronous JavaScript And Xml 。 （async：表示异步，sync：表示同步） 异步的 JavaScript 和 XML。 是一种创建交互式网页应用的网页开发技术。并不是一种新技术，而是一种解决方案，早在在 1998 年就开始使用。 异步表示不阻塞：浏览器在请求数据时，并不会阻塞用户后续的操作。理解为浏览器派了一个小弟去服务器拿数据了。 XML 表示一种数据格式，最初设计 AJAX 时，从服务器返回的数据是 XML 格式的，后面慢慢被 JSON 数据格式取代了。 更具体一点， 浏览器 通过内置对象 XMLHttpRequest 向服务器发起请求，并可以接收服务器返回给浏览器的数据，这一过程或实现这一过程的技术就是我们所说的 Ajax。 # 使用 jQuery 提供的 AJAX 功能 # jquery 体验 ajax 第一个 $.ajax 请求：获取服务器上的时间 common/getCurrentTime 基本流程： 准备工作 确保服务器端是已经就绪的。直接在地址栏中使用接口，测试接口 common/getCurrentTime 新建页面，引入 jquery。 参考给定的 $.ajax 格式，发送请求。 讲解回调函数的含义。 # $.ajax () 的基本格式 1234567891011121314$.ajax( url, // &#x27;/common/getCurrentTime&#x27;, &#123; type: &quot;get&quot;, // post data: &#123; id: 1 &#125;, success: function (result) &#123; console.log(result); &#125;, &#125;);// - url : 表示请求的地址，可以省略域名。// - type: 表示请求的类型，常见取值 get，post。如果不写，默认为&#x27;get&#x27;// - data: 表示发送请求时附加的参数，如果没有参数，可省略// - success：它是一个回调函数。当请求成功之后会自动调用这个函数，它的第一个参数是服务器端返回的数据。 还有其它的配置项，我们在后面再去学习。 # 回调函数 (Callback Functions) 作用：用于对特定的事件或条件进行响应。 两层含义： - 1. 函数。表示它是一个函数，是可以被执行的，能做具体操作的函数。 - 2. 回调。在某个时刻，或者某个事件发生`自动去调用这个函数`。 代码示例： ​ 如下均是回调函数的使用 123456789101112131415161718192021222324$(function()&#123;&#125;)$(document).ready(function()&#123;&#125;)$(&quot;#btn&quot;).click(function()&#123;&#125;)[].sort(function(a,b)&#123; return a - b;&#125;)[1,2,3].forEach(function(item,index,self)&#123;&#125;)function ok(result)&#123; console.log(result)&#125;$.ajax( url,// &#x27;/common/getCurrentTime&#x27;, &#123; type: &#x27;get&#x27;,// post data: &#123;id:1&#125;, success: ok &#125;) 注意： ​ 一般情况下，回调函数都是匿名函数。但，也是可以给它们起名字的。 # 带参数的 get 请求 # 用户名检测 上一个基本示例中，我们的请求并没有带上参数，而在真实的开发中，我们的请求经常是要带参数的。你可以理解为用户名占用检测这个案例就来解决请求接口要带参数的问题。并且用户名占用检测也是一个比好 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-FBJ848MI-1581995138719)(ajax 讲义.assets/ 案例 - 用户名检测.gif)] 目标：仿照博客园注册，实现用户名占用检测效果；学习使用带参数的 get 请求； 测试接口。直接在地址栏中使用接口（common/checkUser），注意在问号后附加参数的问题 给出静态代码 分析要实现的功能； 两种方法传参： 在 url 中拼接参数实现 介绍 $.ajax 的参数中的 data 值，可以简化自己拼接参数的过程。 # jquery-ajax-post # 常见的两种请求方式 get-post get post # 字面理解 不同点： get ：获取，得到。这种方式请求用于向服务器请求资源（图片，文件，数据…）。它是最常见的请求方式。它的重点在于，它只是请求，而 不会改变 服务器上的资源。 post：派送，投递。这种方式的请求用于向服务器上提交数据，它的重点在于，它 可能会修改 服务器上的资源。 相同点 get 和 post 请求都可以在发请求时附带一些数据。例如：根据用户名去检查这个用户是否被占用；在论坛中注册一个账号。 get 和 post 请求都能够从服务器上获取返回的数据。 # 实操对比 get 传数据直接显示在 url 中 - query string parameters post 传递数据更安全 form Data # 常用场景 常见的应用场景适用于 get 还是 post? 查看商品详情 (get) 把一件商品放入购物车 (post) 修改登陆密码 (post) 发表一个帖子 (post) 删除一个用户 (post) 注意：在实际的开发过程中，由于接口是后端同学已经给定的，所以，可能它们能够支持多种请求方式，也可以只支持其中一种。 # JQuery.ajax 实现留言板 目标： 通过 message/addMsg 和 message/getMsg 这两个接口，实现一个动态的留言板功能 基本内容： 效果展示及功能分析 获取留言 发送留言 小结 # 获取留言并显示 基本流程 发送请求 分析回来的数据 使用 forEach 或者 for 循环进行数组遍历，并进行数据拼接 修改显示区的 dom # 模板字符串 在做字符串拼接时，使用 + 来拼接复杂内容是很麻烦的，而模板字符串可以解决这个问题。 格式：` $&#123;变量&#125; $&#123;表达式&#125; ` 语法： 模板字符串使用反引号 `把内容括起来，类似于普通字符串的&quot;&quot;。 ${} 充当界定符的作用，其中可以写变量名，表达式等。 允许字符串内部进行换行，代码更好读更好的体验 示例： 123456789101112131415161718let name = &#x27;zs&#x27;;let age = 18;// 拼接多个变量，在模板字符串中使用占位的方式，更易懂let str = `我是$&#123;name&#125;，今年$&#123;age&#125;`;// 内容过多可以直接换行let obj = [&#123;name: &#x27;flex&#x27;, age: 20&#125;,&#123;name: &#x27;james&#x27;, age: 21&#125;];let arr = [&#x27;175cm&#x27;, &#x27;60kg&#x27;];let html = ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;$&#123;obj.name&#125;&lt;/li&gt; &lt;li&gt;$&#123;obj.age&#125;&lt;/li&gt; &lt;li&gt;$&#123;arr[0]&#125;&lt;/li&gt; &lt;li&gt;$&#123;arr[1]&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; # 原生 ajax 的实现 在实际的开发中，我们会直接使用如 jquery 这样的第三方工具库来调用 ajax，而不会自己去手写一个原生的。但对于学习者来说，深入学习原生 ajax 能帮助我们更好的理解和掌握 。 目标： 能 手写ajax ；掌握 XMLHttpRequest 的用法； # 第一个原生的 ajax 请求 手写一个 ajax 请求，来获取服务器时间。 4 步： new 一个 xhr 对象。 设置请求信息。 设置回调函数，处理请求结果。 发送请求。 123456789101112// 第一步： 新建一个XMLHttpRequest对象(xhr)var xhr = new XMLHttpRequest();// 第二步： 设置请求。 xhr.open(请求的方式，get|post, 请求的url地址);xhr.open(&quot;get&quot;, &quot;common/getCurrentTime&quot;);// 第三步：设置回调函数。返回的数据存放在xhr.responseText中。xhr.onload = function () &#123; console.info(&quot;从服务器返回的数据&quot;, xhr.responseText);&#125;;// 第四步： 发送请求。 xhr.send()xhr.send(); # 理解 XMLHttpRequest 对象 ajax 的功能是基于 XMLHttpRequest 对象来实现的。 它是内置对象，充当构造器使用。 浏览器中的 network 中查看 xhr 属性和方法： open() send() onload(function(){}) responseText # 原生 ajax - 带参数的 get get 带参数 - 检测用户名是否占用 get 带参数的格式：附加在请求的 url 地址后面。 1url?参数1&#x3D;值1&amp;参数2&#x3D;值2&amp;参数3&#x3D;值3... ？ &amp; 123456789101112131415// 第一步： 新建一个XMLHttpRequest对象(xhr)var xhr = new XMLHttpRequest();console.info(xhr);// 第二步： 设置请求。 xhr.open(请求的方式，get|post, 请求的url地址);xhr.open(&quot;get&quot;, &quot;common/checkuser?username=&quot; + username);// 第三步： 发送请求。 xhr.send()xhr.send();// 第四步： 设置回调函数。请求成功之后，获取服务器返回的数据.// 返回的数据存放在xhr.responseText中。xhr.onload = function () &#123; console.info(&quot;从服务器返回的数据&quot;, xhr.responseText);&#125;; # 原生 ajax-post 请求 # post 请求的格式 123456789101112//1. 创建xhr对象var xhr = new XMLHttpRequest();//2. 初始化请求xhr.open(&quot;post&quot;, 服务器地址);//3. 设置请求头，固定写法xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);//4. 监听响应的回调函数xhr.onload = function () &#123; console.log(xhr.responseText);&#125;;//5. 发送请求xhr.send(&quot;提交给服务器数据字符串&quot;); // &#x27;a=1&amp;b=3&#x27; 注意： 要设置请求头 提交给服务器的数据写在 send () 中。 # 案例：用户登陆 * 代码资料： 12345678910111213141516171819202122232425262728&lt;style&gt; .container &#123; width: 800px; padding: 2em; margin: 40px auto; border: 1px solid #ccc; &#125; .container label &#123; display: inline-block; width: 80px; &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;h2&gt;用户登陆&lt;/h2&gt; &lt;p&gt;正确的账号信息是:用户名admin,密码admin&lt;/p&gt; &lt;div&gt; &lt;label for=&quot;userName&quot;&gt;用户名&lt;/label &gt;&lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;userName&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label &gt;&lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; id=&quot;password&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;button id=&quot;btnLogin&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;/div&gt; 整体分析 传参 content-type:application/x-www-form-urlencoded 设置与不设置头的区别： 一定设置请求头。 # 原生 ajax 中 get 和 post 区别 get 参数拼接在 url（ url?name=1&amp;age=30 ） 由于浏览器对 url 长度的支持（各个浏览器均不同）是有限，所以，它只能附加少量的数据。 post 要设置请求头: xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') 参数写在 send () 方法中: send('name=1&amp;age=30') 相对于 get 来说，没有传参大小的限制。 # onreadystatechange 事件和 readyState 属性 # onreadystatechange 事件 onload 是 HTML5 （2014 年 9 月）以后新增的方便获取响应的事件，一些老的浏览器 (ie6,ie7,ie8) 对 onload 是不支持的。通过代码来验证这一点：以下代码在 ie6,ie7,ie8 中并不能使用。 12345678var xhr = new XMLHttpRequest();// open 方法的第一个参数的作用就是设置请求的 methodxhr.open(&quot;get&quot;, &quot;common/getCurrentTime&quot;);xhr.onload = function () &#123; alert(&quot;ok&quot;);&#125;;xhr.send(); 在 html5 之前，获取服务器返回内容的时候使用的是 onreadystatechange 事件，这个事件是在 xhr 对象状态变化时被触发，而一次请求过程中， XMLHttpRequest 对象的状态会发生 多次变化 ，也就意味着这个事件会被触发多次。 onreadystatechange 12345678var xhr = new XMLHttpRequest();// open 方法的第一个参数的作用就是设置请求的 methodxhr.open(&quot;get&quot;, &quot;common/getCurrentTime&quot;);// onreadystatechangexhr.onreadystatechange = function () &#123; console.log(&quot;事件被触发了&quot;);&#125;;xhr.send(); # xhr 对象的状态 一共有 5 种，用 readyState 属性表示，详见下表 readyState 状态描述 说明 0 UNSENT XHR 被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用，建立了连接。 2 HEADERS_RECEIVED send() 方法已经被调用，并且已经可以获取状态行和响应头。 3 LOADING 响应体下载中， responseText 属性可能已经包含部分数据。 4 DONE ** 响应体下载完成，可以直接使用 responseText 一次正常的 send () 话，xhr.readStatus 的值的变化是： 10 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-Oax7sEsH-1581995138723)(ajax 讲义.assets/1559037455667.png)] # get 请求在 IE 中的缓存问题 如下代码，在 ie 中运行： 123456789101112131415161718192021&lt;div&gt; &lt;button id=&quot;btn&quot;&gt;获取时间&lt;/button&gt;&lt;label for=&quot;&quot; id=&quot;lblTimer&quot;&gt;&lt;/label&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(&#x27;btn&#x27;).onclick = function() &#123; var xhr = new XMLHttpRequest(); console.log(xhr.readyState); // open 方法的第一个参数的作用就是设置请求的 method xhr.open(&#x27;get&#x27;, &#x27;common/getCurrentTime&#x27;); console.log(xhr.readyState); xhr.send(); // 更改事件为onreadystatechange xhr.onreadystatechange = function() &#123; // 表示从服务器端返回的数据已经全部ok了。 if (xhr.readyState == 4) &#123; document.getElementById(&#x27;lblTimer&#x27;).innerHTML = xhr.responseText; &#125; &#125;;&#125;;&lt;/script&gt; 出现的原因： 每次请求的地址都一样，浏览器自作聪明去使用了第一次请求的结果。 解决方法 骗浏览器，让它以为 每次的请求都不一样 http://localhost:3005/common/getCurrentTime?_t=1559038330427 12345678910111213141516document.getElementById(&quot;btn&quot;).onclick = function () &#123; var xhr = new XMLHttpRequest(); console.log(xhr.readyState); // open 方法的第一个参数的作用就是设置请求的 method var time = Date.now(); // 附加一个变化的值 xhr.open(&quot;get&quot;, &quot;common/getCurrentTime?_t=&quot; + time); console.log(xhr.readyState); xhr.send(); // 更改事件为onreadystatechange xhr.onreadystatechange = function () &#123; // 表示从服务器端返回的数据已经全部ok了。 if (xhr.readyState == 4) &#123; document.getElementById(&quot;lblTimer&quot;).innerHTML = xhr.responseText; &#125; &#125;;&#125;; 以 jd.com 为例 loginservice.aspx # 服务器端返回的数据格式 前端人员通过 ajax 请求从服务器获取数据，数据拿回来之后，可能还需要做一步的操作，例如：如果是一个数组，则要遍历数组。 那么掌握服务器返回的数据的表现形式是非常重要的环节，只有知道了这些格式，我们才能更好去处理这些数据。 了解服务器端返回数据在类型上的区别；会对 json 进行操作；简单了解 xml； 内容： 观察三种不同的返回值 深入学习 JSON 简单学习 XML # 了解三个不同结构的字符串 引入：以 4 大名著书本信息为例，比较三种文件的回传的数据比较。 文本：普通字符串 json：json 格式的字符串 xml：xml 格式的字符串 直接在浏览器中打开三个接口，列出结果如下： 格式 1： 1作者：吴承恩，书名：西游记；作者：施耐庵，书名：水浒传；作者：罗贯中，书名：三国演义；作者：曹雪芹，书名：红楼梦 格式 2： 123456[ &#123; author: &quot;吴承恩&quot;, name: &quot;西游记&quot; &#125;, &#123; author: &quot;施耐庵&quot;, name: &quot;水浒传&quot; &#125;, &#123; author: &quot;罗贯中&quot;, name: &quot;三国演义&quot; &#125;, &#123; author: &quot;曹雪芹&quot;, name: &quot;红楼梦&quot; &#125;,]; 格式 3 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;booklist&gt;&lt;book&gt; &lt;author&gt;吴承恩&lt;/author&gt; &lt;name&gt;西游记&lt;/name&gt;&lt;/book&gt;&lt;book&gt; &lt;author&gt;施耐庵&lt;/author&gt; &lt;name&gt;水浒传&lt;/name&gt;&lt;/book&gt;&lt;book&gt; &lt;author&gt;罗贯中&lt;/author&gt; &lt;name&gt;三国演义&lt;/name&gt;&lt;/book&gt;&lt;book&gt; &lt;author&gt;曹雪芹&lt;/author&gt; &lt;name&gt;红楼梦&lt;/name&gt;&lt;/book&gt;&lt;/booklist&gt; 哪一种格式的字符串更好读？为什么？ Tip: 同样是作文，字迹字体也有工整之分。 # JSON 发送 ajax 请求时，从服务器端返回的数据格式要统一，这样才能让不同的后端语言，不同的前端人员都 能读懂，都方便操作，而这时，我们就可以使用 JSON 格式。 它用于描述数据，它比普通字符串更具有表达力！ # 如何判断返回值是 JSON 字符串 观察几个真实的 JSON 数据： 从服务器返回的数据都是字符串格式的，如何判断数据是 JSON 字符串格式的？ [在线验证 json 格式](http://www.bejson.com/） tip: 直接在线进行字符串校验，判断一个字符串是不是 json 字符串。 # JSON 是什么 JSON: JavaScript Object Notation (JavaScript 对象表示法) 。 JSON 是一种通过普通字符串描述数据的手段，用于表示有结构的数据。 JSON 是轻量级的文本数据交换格式，类似 XML。 JSON 独立于编程语言 （php,java,go,js 都会通过它来进行数据交流） JSON 具有自我描述性，更易理解 # JSON 字符串常见格式 作为前端人员，我们是通过调用服务器端接口的方式来获取 JSON 字符串，也就是说，我们一拿到数据，它是 JOSN 格式的，而这个 JSON 格式的数据显然是由后端同学给提供的。 但是，我们也要知道如何去写出一个标准的 JSON 字符串。 有如下三种情况： 普通字符串 数组字符串 12&#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#x27;; 做法是：在 javascript 数组前后加上单引号，变成字符串就行。 对象字符串 1&quot;&#123;\\&quot;name\\&quot;:\\&quot;curry\\&quot;,\\&quot;age\\&quot;:40&#125;&quot; 做法是： 在 javascript 对象的属性名加上’双引号’（ 不能用单引号 ）; 把整个对象前后加上单引号 # JSON 字符串相关的两个操作 把 JSON 字符串转成具体某个编程语言中的数据格式； 在某个编程语言中，把数据格式转成 JSON 字符串； [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-deUUB9Z2-1581995138725)(ajax 讲义.assets/1559101747981.png)] 从 JSON 字符串转成编程语言支持的数据 从数据类型转成 JSON 字符串 js JSON.parse() JSON.stringify() php json_decode() json_encode() java JSON.parseObject(),JSON.parseArray() JSON.toJSONString js 中提供了一个静态对象 JSON 来处理 json。 它与 Math 相似，不需要 new，而是直接通过对象名。方法来调用。 # JSON.stringify 功能：把 js 数据，转成 JSON 格式的字符串 格式： var JSON字符串 = JSON.stringify(js数据) 12345678910// 1.把js中的数组，对象 转成 JSON字符串var arr = [1, 2, 3, &quot;ok&quot;, &quot;hello&quot;];var arr_jsonStr = JSON.stringify(arr);console.info(arr, typeof arr);console.info(arr_jsonStr, typeof arr_jsonStr);var obj = &#123; name: &quot;flex&quot;, age: 30, favoriate: [&quot;篮球&quot;, &quot;前端&quot;] &#125;;var obj_jsonStr = JSON.stringify(obj);console.info(obj, typeof obj);console.info(obj_jsonStr, typeof obj_jsonStr); # JSON.parse 功能：把 JSON 格式的字符串，还原成 JS 中的数据格式 格式： var JS数据 = JSON.parse(JSON字符串) # 案例：把四大名著 json 字符串以表格的形式显示 # XML (简单了解) 可扩展标记语言（Extensible Markup Language）。 XML 于 1998 年 2 月 10 日成为 W3C 的推荐标准。 它提供了一种描述结构数据的格式，简化了网络中数据交换和表示，使得代码、数据和表示分离，并作为数据交换的标准格式。 独立于编程语言的。 AJAX（异步的 javascript 和 XML）中的 X 就是 XML # 示例 假设这个文件的名字为 books.xml 12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;&lt;booklist&gt;&lt;book&gt; &lt;author&gt;吴承恩&lt;&#x2F;author&gt; &lt;name&gt;西游记&lt;&#x2F;name&gt;&lt;&#x2F;book&gt;&lt;book&gt; &lt;author&gt;施耐庵&lt;&#x2F;author&gt; &lt;name&gt;水浒传&lt;&#x2F;name&gt;&lt;&#x2F;book&gt;&lt;book&gt; &lt;author&gt;罗贯中&lt;&#x2F;author&gt; &lt;name&gt;三国演义&lt;&#x2F;name&gt;&lt;&#x2F;book&gt;&lt;book&gt; &lt;author&gt;曹雪芹&lt;&#x2F;author&gt; &lt;name&gt;红楼梦&lt;&#x2F;name&gt;&lt;&#x2F;book&gt;&lt;&#x2F;booklist&gt; # 操作（了解） 如果 ajax 所请求的接口，明确规定返回值是 xml 格式，你可以通过： 通过 xhr.responseXML 来获取内容。 拿到这个内容之后，就像操作 dom 元素一样去访问其中的内容。 12345var books = xhr.responseXML.getElementsByTagName(&quot;book&quot;);for (var index = 0; index &lt; books.length; index++) &#123; var element = books[index]; console.info(element.getElementsByTagName(&quot;author&quot;)[0].innerHTML);&#125; # XML VS JSON 相同点： 都用来 描述数据格式 与具体的 编程语言无关 有自己文件格式的后缀名.xml 和.json 的文件 区别 JSON 有简易的语法（javascript 基因）；XML 有规范的标签（html 基因） JSON 存储效率更高 # 同步和异步 同步和异步是面试中经常会被问到的知识点，下面我们通过 ajax 来学习这个概念。 内容： - 对比生活中的例子理解 同步和异步 - 简单代码认识异步的效果 - ajax中的异步 - ajax中的同步 # 生活中的同步异步 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-uJBo8elU-1581995138729)(ajax 讲义.assets/1561249167046.png)] 同步方式： 一个时刻只能做一件事； 我： 写代码 我：买咖啡，自己去买，花 2 小时 我：写代码 异步方式：不是一件接一件做，而是可能同时做多件事情； - 我： 写代码 - 我： 买咖啡，安排别人去买，跳过这一步，我自己不做。 - 我： 写代码 # ajax 定义同步和异步 原生的 ajax 中，xhr.open () 方法的第三个参数就可以决定同步和异步的方式。 1234xhr.open(参数1 ，参数2，参数3)- 参数1 ：请求的方式. get，post- 参数2 ：请求的url地址。- 参数3 ：是否启用异步模式，默认为true，即异步， `如果设置为false，就是同步`。 以请求黑盒服务器的接口 sleep 为例（这个接口已经预先写好了，直接调用即可） 1234567// 创建ajax，设置，并发送请求var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;common/sleep&quot;); // 第三个参数不写，默认是异步xhr.onload = function () &#123; console.info(&quot;现在的时间是：&quot;, new Date().toLocaleTimeString());&#125;;xhr.send(); // 发送。 改成 true 和 false 观察效果。 # 异步的 ajax xhr.open () 默认是异步的。通过下面的代码来理解异步。 12345678910111213// 1. 先输出一行提示代码console.info(&quot;1 现在的时间是：&quot;, new Date().toLocaleTimeString());// 2. 创建ajax，设置，并发送请求var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;common/sleep&quot;); // 第三个参数不写，默认是异步xhr.onload = function () &#123; console.info(&quot;2 现在的时间是：&quot;, new Date().toLocaleTimeString());&#125;;xhr.send(); // 发送。// 3.再输出一行提示代码console.info(&quot;3 现在的时间是：&quot;, new Date().toLocaleTimeString()); 异步执行流程： 浏览器：输出 1 浏览器：执行 send (), 发现是异步的，跳过这一步（不会阻塞代码，理解为：不用自己亲自做，找别人去做） 浏览器：输出 3 注意： 异步ajax时，onload，可以写在send之后 # 同步的 ajax 1234xhr.open(参数1 ，参数2，参数3)- 参数1 ：请求的方式。 get，post- 参数2 ：请求的url地址。- 参数3 ：是否启用异步模式，默认为true，即异步， `如果设置为false，就是同步`。 123xhr.open(&#x27;get&#x27;, &#x27;common/getCurrentTime&#x27;); // 异步xhr.open(&#x27;get&#x27;, &#x27;common/getCurrentTime&#x27;，true); // 异步xhr.open(&#x27;get&#x27;, &#x27;common/getCurrentTime&#x27;, false);// 同步 同步代码中，onload 必须写在 send 之前。 同步执行流程： 浏览器：输出 1 浏览器：执行 send (), 发现是同步， 只能死等 。 整个代码块卡在 send 这句。 浏览器：输出 3 如果你设置成了同步的方式，你会在浏览器看到如下的错误信息： [Deprecation] Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help, check https://xhr.spec.whatwg.org/. 有几个单词： Synchronous: 同步的 deprecate: 反对的，不赞成 detrimental：有害的，不利的 翻译一下就是：[deprecation] 由于主线程上的同步 xmlhttpRequest 对最终用户的体验有不利影响，因此不推荐使用它。有关更多帮助，请查看 https://xhr.spec.whatwg.org/ # 原生 ajax 代码封装 对前面学习的 get 请求有 4 步，post 请求有 5 步，下面对这些代码封装，以提高效率。 封装代码的工作，我们可以从实现了某个具体功能的代码出发，例如前面用到的 common/get 请求的例子 初始代码 1234567// 创建ajax，设置，并发送请求var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;common/get?a=1&amp;b=2&quot;);xhr.onload = function () &#123; console.info(&quot;现在的时间是：&quot;, new Date().toLocaleTimeString());&#125;;xhr.send(); // 发送。 # 加括号，变成一个函数 给取一个响应的名字 hiAjax 1234567891011function hiAjax() &#123; // 创建ajax，设置，并发送请求 var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;common/get?a=1&amp;b=2&quot;); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; xhr.send(); // 发送。&#125;hiAjax(); # 提炼出 type 参数 123456789function myAjax(type) &#123; var xhr = new XMLHttpRequest(); xhr.open(type, &quot;common/get?a=1&amp;b=2&quot;); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; xhr.send();&#125;myAjax(&quot;get&quot;); # 提炼出 url 和 data 123456789101112function myAjax(type, url, data) &#123; var xhr = new XMLHttpRequest(); if (data) &#123; url += &quot;?&quot; + data; &#125; xhr.open(type, url); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; xhr.send();&#125;myAjax(&quot;get&quot;, &quot;common/get&quot;, &quot;a=1&amp;b=2&quot;); # 处理 post 请求 第一步：直接通过 if,else 进行两类的处理 1234567891011121314151617181920212223function myAjax(type, url, data) &#123; if (type == &quot;post&quot;) &#123; var xhr = new XMLHttpRequest(); xhr.open(type, url); xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; xhr.send(data); &#125; else if (type == &quot;get&quot;) &#123; var xhr = new XMLHttpRequest(); if (data) &#123; url += &quot;?&quot; + data; &#125; xhr.open(type, url); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; xhr.send(); &#125;&#125;myAjax(&quot;get&quot;, &quot;common/get&quot;, &quot;a=1&amp;b=2&quot;);myAjax(&quot;post&quot;, &quot;common/post&quot;, &quot;a=1&amp;b=2&quot;); 第二步：优化代码 把 if,else 中的相同的代码提出来 12345678910111213141516171819function myAjax(type, url, data) &#123; var xhr = new XMLHttpRequest(); if (type == &quot;get&quot; &amp;&amp; data) &#123; url += &quot;?&quot; + data; &#125; xhr.open(type, url); xhr.onload = function () &#123; console.log(xhr.responseText); &#125;; if (type == &quot;post&quot;) &#123; xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(data); &#125; else if (type == &quot;get&quot;) &#123; xhr.send(); &#125;&#125;myAjax(&quot;get&quot;, &quot;common/get&quot;, &quot;a=1&amp;b=2&quot;); # 支持回调函数 全局函数 函数传参 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 功能 ： 发出ajax请求 * 参数： * type: 类型是字符串。支持的取值是 &quot;get&quot;,&quot;post&quot;。决定ajax请求的类型 * data: 传给服务器的数据。支持的格式是字符串：a=1&amp;b=2&amp;c=3 * url : 请求的地址, * sucess: 请求成功之后的回调函数。第一个参数是服务器返回的数据 * * 示例： hiAjax(&#x27;get&#x27;, &#x27;name=ok&#x27;, &#x27;common/get&#x27;, function(result) &#123; console.info(&#x27;get&#x27;, result); &#125;); hiAjax(&#x27;get&#x27;, &#x27; &#x27;, &#x27;common/get&#x27;,dosomething1); hiAjax(&#x27;get&#x27;, &#x27;&#x27;, &#x27;common/get&#x27;,dosomething2); */function hiAjax(type, data, url, success) &#123; var xhr = new XMLHttpRequest(); if (type === &quot;post&quot;) &#123; xhr.open(type, url); xhr.setRequestHeader(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(data); &#125; else if (type === &quot;get&quot;) &#123; //如果 data有值，就在url后追加 // trim() 用来清除字符串前后的空格 if (data.trim()) &#123; url = url + &quot;?&quot; + data; &#125; xhr.open(type, url); xhr.send(); &#125; else &#123; alert(&quot;不支持这个格式的请求:&quot; + type); return; &#125; xhr.onload = function () &#123; success(xhr.responseText); &#125;;&#125;function dosomething1(result) &#123; alert(&quot;1&quot;); console.info(xhr.responseText); // alert(1);&#125;function dosomething2(result) &#123; alert(&quot;2&quot;); console.info(xhr.responseText); // alert(1);&#125;// 每个请求，从服务器中返回数据之后，都是直接在控制台中输出。// hiAjax(&#x27;post&#x27;, &#x27;a=1&amp;b=2&#x27;, &#x27;common/post&#x27;, dosomething1);hiAjax(&quot;get&quot;, &quot;name=ok&quot;, &quot;common/get&quot;, function (result) &#123; console.info(&quot;get&quot;, result);&#125;);hiAjax(&quot;get&quot;, &quot; &quot;, &quot;common/get&quot;, dosomething1);hiAjax(&quot;get&quot;, &quot;&quot;, &quot;common/get&quot;, dosomething2); # 总结 封装的基本过程： 埋头苦干 。写出基本的，能正确运行的代码段 一名惊人 。使用 function 包裹，变成一个可以被调用的函数； 从死到活 。从具体到抽象。函数内部的固定数据抽成参数，同时写函数文档。 黑盒测试 。列出多维度的测试用例，逐一验证。 升级优化 目前 data 这个参数只是查询字符串的格式，是否可让它支持对象格式？ # 其它 ajax 库的使用 # jquery 中的 ajax 方法 # $.ajax 的其它选项 1234567891011121314151617$.ajax(url,&#123; type: &#39;get&#39;, dataType: &#39;json&#39;, data: &#123; id: 1 &#125;, beforeSend: function (xhr) &#123; console.log(&#39;before send&#39;) &#125;, success: function (data) &#123; console.log(data) &#125;, error: function (xhr) &#123; console.log(xhr) &#125;, complete: function (xhr) &#123; console.log(&#39;request completed&#39;) &#125;&#125;) 常用选项参数介绍： url：请求地址 type /method：请求方法，默认为 get data：需要传递到服务端的数据。字符串和对象均可。如果是对象会自动拼接成字符串 success：请求成功之后触发 cache: 设置 ie 浏览器的缓存问题。默认为 true，表示缓存。 cache: false 不缓存。 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-RXPLp7KP-1581995138732)(ajax 讲义.assets/1559188688467.png)] dataType：预期服务端返回的数据方式。如不指定，它会自动判断。 contentType：请求体内容方式，默认 application/x-www-form-urlencoded timeout：请求超时时间。 beforeSend：请求发起之前触发 complete：请求完成触发（不管成功与否） error：请求失败触发 processData:boolean。是否让 jquery 帮助处理传到服务器的数据 # $.ajax 方法的简便用法 $.get() $.post() $.getJSON() # $.get 的格式 对于比较简单的 get 请求，jquery 提供了一个快捷方法 $.get () 12345$.get(url,[,data][,success]);参数： - url ：字符串方式。指要请求的 URL 地址。 - data : js对象，或者字符串方式。 可选的。 指发请求带给服务器的信息。 - success : function(result)&#123;&#125; 。 可选的。它是一个回调函数，当请求成功时被自动调用，它的第一个参数是从服务器返回的数据。 # $.post 的格式 12345$.post(url,[,data][,success]);参数：- url ：字符串方式。指要请求的 URL 地址。- data : js对象，或者字符串方式。 可选的。 指发请求带给服务器的信息。- success : function(result)&#123;&#125; 。 可选的。它是一个回调函数，当请求成功时被自动调用，它的第一个参数是从服务器返回的数据。 # $.getJSON 12345$.getJSON(url,[,data][,success]);参数： - url ：字符串方式。指要请求的 URL 地址。 - data : js对象，或者字符串方式。 可选的。 指发请求带给服务器的信息。 - success : function(json)&#123;&#125; 。它是一个回调函数，当请求成功时被自动调用，它的参数是从服务器返回的JSON数据。 # axios 库 jquery 中封装了 ajax 功能，但是它的体积比较大。如果我们只希望使用 ajax 功能，而不需要 dom 操作的话，我们可以选择使用 axios 库。(fetch) 应用： - 它只专注于处理http请求，比jquery的体积小的多，适用于只需要ajax请求的业务场景； - 后期学习三大前端框架时也会用到； # 使用示例 通过官网查看其使用方法。 与 jquery 一样，要使用它，必须先引入这个文件。然后就可以按如下的格式去使用了。 中文网站：&lt;http://www.axios-js.com/zh-cn/docs/ 12345678910111213141516171819202122232425// 获取服务器的返回值axios.get(&quot;/common/get?id=123&quot;).then(function (res) &#123; // res 就是本次请求的信息 console.info(res); // 获取 从服务器返回的数据 console.info(res.data);&#125;);axios .get(&quot;/common/get&quot;, &#123; params: &#123; id: 123, name: &quot;jake&quot; &#125; &#125;) .then(function (res) &#123; // res 就是本次请求的信息 console.info(res); // 获取 从服务器返回的数据 console.info(res.data); &#125;);// post请求，不带参数axios.post(&quot;/common/post&quot;).then(function (res) &#123; console.info(res.data);&#125;);// post请求，带参数axios.post(&quot;/common/post&quot;, &#123; id: 123, name: &quot;jake&quot; &#125;).then(function (res) &#123; console.info(res.data);&#125;); # 是什么 ​ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。相比 jquery 它只专注于 ajax 请求。 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF # XMLHttpRequest 2.0 XMLHttpRequest 2.0（2012 年）中的新增功能一些功能我们重点给大家介绍如下两个内容： https://xhr.spec.whatwg.org/ responseType FormData # responseType / response responseType：响应类型。表示对从服务器端回来数据的期待，即我们希望从服务器回来的数据是什么类型的。 # 使用场景 在前面使用原生的 ajax 过程中，我们提到了从服务器端获取的数据一般从 xhr.responseText 中获取，而这个值一般情况下是一个 json 字符串，所以我们要使用 JSON.parse () 来转一下这个字符串。 但是，如果 已经确切地知道 了从服务器端回来的数据格式是 JSON 字符串，那么我们在发出 ajax 请求之前，提前去设置 xhr.responseType 属性值，这样得到的数据就可以直接从 xhr.response 中拿了。 如果你已经能够知道从服务器中返回的数据类型，就可以通过: 预先设置 xhr.responseType = “类型名” 直接从 xhr.response 中拿结果 # 基本介绍 responseType – 预期服务器返回数据的类型 “” – 空，表示文本，和 text 一样。空为默认值 text – 文本 json – JSON 格式数据 document – 文档对象 response – 根据 responseType 的值自动处理返回结果，可以接收任何类型的结果 # 示例 123456789101112var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;common/get?id=123&amp;name=jake&quot;);xhr.send();xhr.responseType = &quot;json&quot;;xhr.onload = function () &#123; // responseText // 只有当responseType是&quot;&quot; 或者是&quot;text&quot;时才只可以使用； // console.info(typeof xhr.responseText); // console.info(JSON.parse(xhr.responseText)); console.info(typeof xhr.response); console.info(xhr.response);&#125;; 不需要再次对 xhr.responseText 进行转换 不能再使用 xhr.responseText，会报错。应该使用 xhr.response # FormData FormData：表单数据（官方 api 参考）。故名思义，它是用来处理 html 中与表单数据相关的操作的。 在 ajax 的使用过程， 一般先要收集用户的信息，然后再把信息通过 post（或者 get）的方式传递到后端。FormData 的使用就是在收集用户信息这个部分。 它主要有如下两个使用场景： 快速收集 form 表单中元素的信息，减少表单元素的拼接，提高工作效率 上传文件 # 快速获取表单中的元素值 静态页面代码 12345678910111213141516&lt;form id=&quot;myform&quot;&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; name=&quot;userName&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;性别&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;genderMale&quot; name=&quot;userGender&quot; value=&quot;male&quot; /&gt;男 &lt;input type=&quot;radio&quot; id=&quot;genderFemale&quot; name=&quot;userGender&quot; value=&quot;female&quot; /&gt;女 &lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;注册&lt;/button&gt;&lt;/div&gt;&lt;/form&gt; # 不用 FormData 123456789101112131415161718192021222324document.getElementById(&quot;btn&quot;).onclick = function () &#123; //收集用户信息 var userName = document.getElementById(&quot;userName&quot;).value; var userPassword = document.getElementById(&quot;userPassword&quot;).value; var userGender = &quot;&quot;; if (document.getElementById(&quot;genderMale&quot;).checked) &#123; userGender = &quot;male&quot;; &#125; else if (document.getElementById(&quot;genderFemale&quot;).checked) &#123; userGender = &quot;famale&quot;; &#125; console.info(userName, userPassword, userGender); // 通过post传值 var xhr = new XMLHttpRequest(); xhr.responseType = &quot;json&quot;; xhr.open(&quot;post&quot;, &quot;common/post&quot;); xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send( `userName=$&#123;userName&#125;&amp;userPassword=$&#123;userPassword&#125;&amp;userGender=$&#123;userGender&#125;` ); xhr.onload = function () &#123; console.info(xhr.response); &#125;;&#125;; # 使用 FormData 1234567891011121314151617document.getElementById(&quot;btn&quot;).onclick = function () &#123; //收集用户信息 var fd = new FormData(document.getElementById(&quot;myform&quot;)); // 通过post传值 var xhr = new XMLHttpRequest(); xhr.responseType = &quot;json&quot;; xhr.open(&quot;post&quot;, &quot;common/post&quot;); // 不用设置请求头 // xhr.setRequestHeader( // &#x27;Content-type&#x27;, // &#x27;application/x-www-form-urlencoded&#x27; // ); xhr.send(fd); xhr.onload = function () &#123; console.info(xhr.response); &#125;;&#125;; 要注意： FormData 对象内部有一个键值对集合，其中的键名就是表单元素的 name 属性名，而值就是这个表单元素当前的值。 # FormData 对象的 api https://developer.mozilla.org/zh-CN/docs/Web/API/FormData 12345678910111213141516171819var fd = new Formdata();fd.append(key, value);// 向 FormData 中添加新的属性值，如果FormData 对应的属性值存在则覆盖原值，否则新增一项属性值。fd.delete(key);// 从 FormData 对象里面删除一个键值对。fd.entries();// 返回一个包含所有键值对的iterator对象。fd.get(key);//返回在 FormData 对象中与给定键关联的第一个值。fd.getAll(key);//返回一个包含 FormData 对象中与给定键关联的所有值的数组。fd.has(key);//返回一个布尔值表明 FormData 对象是否包含某些键。fd.keys();//返回一个包含所有键的iterator对象。fd.set(key, value);//给 FormData 设置属性值，如果FormData 对应的属性值存在则覆盖原值，否则新增一项属性值。fd.values();//返回一个包含所有值的iterator对象。 # 自定义键值对 上面的案例中，我们是从表单中快速获取所有的表单元素的值，并以键值的形式保存在 FormDate 对象中。除了这种方法之外，还可以手动决定收集哪些值，或者额外添加哪些值。 1234567891011121314151617181920212223242526272829303132333435// 使用FormDatadocument.getElementById(&quot;btn&quot;).onclick = function () &#123; //收集用户信息 var fd = new FormData(); // 数据在FormData内部是以键-值对的格式存在的. // 获取：值 // 格式： fd.get(键名 ) // 向fd中追加一个键值对 fd.append(&quot;userName&quot;, document.getElementById(&quot;userName&quot;).value); fd.append(&quot;userPassword&quot;, document.getElementById(&quot;userPassword&quot;).value); var userGender = &quot;&quot;; if (document.getElementById(&quot;genderMale&quot;).checked) &#123; userGender = &quot;male&quot;; &#125; else if (document.getElementById(&quot;genderFemale&quot;).checked) &#123; userGender = &quot;famale&quot;; &#125; fd.append(&quot;userGender&quot;, userGender); //console.info(fd.get(&#x27;email&#x27;)); // 通过post传值 var xhr = new XMLHttpRequest(); xhr.responseType = &quot;json&quot;; xhr.open(&quot;post&quot;, &quot;common/post&quot;); // 不用设置请求头 // xhr.setRequestHeader( // &#x27;Content-type&#x27;, // &#x27;application/x-www-form-urlencoded&#x27; // ); xhr.send(fd); xhr.onload = function () &#123; console.info(xhr.response); &#125;;&#125;; # 简单上传文件 在浏览器端，文件上传功能可以通过很简单的代码就能实现，而复杂的地方在服务器端。黑盒服务器已经预制了一个接口，可以用来上传文件。接口名地址是： formdata/upload 使用这个接口有两点注意： 这个接口只能接收 formdata 对象，并且你上传的文件信息必须是保存在名为 file 的键中。也就是说 input 的 name 值必须是 file 。 app.exe 的同级目录下必须有 upload 文件夹。这个文件夹就是用来保存上传的文件的。 核心代码如下： 12345678910111213141516171819202122&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;FormData文件上传&lt;/h1&gt; &lt;form id=&quot;myForm&quot;&gt; &lt;label for=&quot;&quot;&gt;请选择你要上传的文件&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;/form&gt; &lt;div&gt; &lt;button id=&quot;btn&quot;&gt;上传&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(&#x27;btn&#x27;).onclick = function() &#123; var fd = new FormData(document.getElementById(&#x27;myForm&#x27;)); var xhr = new XMLHttpRequest(); xhr.open(&#x27;post&#x27;, &#x27;formdata/upload&#x27;); xhr.onload = function() &#123; console.info(xhr.responseText); &#125;; xhr.send(fd); &#125;; &lt;/script&gt; # 上传文件进度条 onprogress 这个案例是在上一个案例的基础上进行拓展：让上传文件的过程可视化。 核心： xhr 对象中有一个子对象 upload，upload 对象中有一个事件 onprogress。 onprogress 事件大约每 100ms 触发一次，其回调函数第一个参数是一个事件对象，这个事件对象中有两个属性 loaded 和 total loaded：表示已上传文件的大小 total： 表示文件总大小 实现思路： 制作进度条，使用两层嵌套的 div 即可：第一层是进度条的外边框，第二层才是进度条 每次 onprogress 事件触发时： 都计算当前已上传文件大小的百分比 根据百分比去重绘进度条长度（宽度值可以是百分比值） 参考资料：静态页面中的样式 123.outer &#123; height: 20px; background: #171b3c; border-radius: 20px; box-shadow: 02px 2px #4f4c4c; margin-bottom: 40px; position: relative; &#125; .inner &#123; position:absolute; border-radius: 20px; width: 0%; height: 20px; background: #ef2d56; &#125; 参考资料：核心代码 1234567891011121314151617document.getElementById(&quot;btn&quot;).onclick = function () &#123; var innerDom = document.getElementById(&quot;inner&quot;); var fd = new FormData(document.getElementById(&quot;myForm&quot;)); var xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, &quot;formdata/upload&quot;); xhr.onload = function () &#123; console.info(xhr.responseText); &#125;; xhr.upload.onprogress = function (ev) &#123; console.info(Date.now()); // 已上传 / 总大小 console.info((ev.loaded / ev.total) * 100 + &quot;%&quot;); // 设置百分比值 innerDom.style.width = (ev.loaded / ev.total) * 100 + &quot;%&quot;; &#125;; xhr.send(fd);&#125;; # 综合案例 - 会员管理 目标：实现一个相对复杂的功能 会实现无限加载 会用 $.ajax 发 ajax 请求 会用 postman 内容 项目整体介绍 postman 使用 项目实现 # 基本介绍 # 项目功能介绍 添加会员 删除会员 查看会员列表 查看会员详情 会员列表（无限加载） # 项目的开发要点 前后端分离开发 前端使用 bootstrap+ jquery 使用 postman 对接口进行测试 后端准备好相关接口以供前端调用 # 项目接口列表 list list-last detail delete add # 接口名：list url: /member/list 功能：取出全部会员信息 类型: get 参数：无 返回值：取到的记录列表 # 接口名：list-last url: /member/list-last 功能：取出从当前记录（last）之后的 6 条记录 类型: get 参数： ​ - last: 指定的从哪条记录（id 号）开始取 。如果不设置值，就取最新的 6 个成员 返回值：取到的记录列表 示例： member/list-last?last=100 。获取编号为 100 之后的 6 条数据 # 接口名：detail url: /member/detail 功能：获取指定编号的会员详情 类型: get 参数： ​ - id: 会员的编号。必传。 返回值：会员详情。 # 接口名：delete url: /member/delete 功能：删除指定编号的会员 类型: post 参数： ​ - id: 会员的编号。必传 返回值：无 # 接口名：add url: /member/add 功能：添加会员 类型: post 参数： - name: 名字 - avatar: 头像文件，是一个图片文件 - bio: 介绍 返回值：{} 注意： 必须要确保在public下面有一个upload文件夹 # postman 对于 get 类型的接口，我们可以直接在地址栏中输入地址去发请求，对于 post 请求，测试起来就不方便了。这种情况下，我们就需要专业的接口测试工具了，这里给大家推荐 postman。 对后端提供的接口进行测试； 前端必备工具； 基本操作 下载，安装 启动 测试接口 要点： 选择参数 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-2lksBzee-1581995138736)(ajax 讲义.assets/1561186856276.png)] # 查看会员详细信息 整体分析 流程分析 接口测试 从 url 中取值 发送请求，更新页面元素 # 删除会员 思路： 给每个删除链接上，补充成员 id。 给每个删除链接上，补充’href=“javascript:;”’，这样可以阻止默认的跳转事件。 给弹出框中的删除按钮添加点击事件 获取上面的 label 中的 id。 发 ajax 请求，进行删除 重点代码： 取消 a 标签的跳转动作 1&lt;a href=&quot;javascirpt:;&quot; /&gt; 添加事件委托 问题描述：元素是动态生成的，无法直接给元素添加点击事件。解决方法：给其父元素添加事件监听。由于元素上的事件具有冒泡特性：在子元素上的点击事件最终也会冒泡到父元素上。所以可以直接在父元素上监听。 123$(&quot;#parent&quot;).on(&quot;click&quot;, &quot;.son&quot;, function () &#123; // ....&#125;); # 新增会员 文件控件 本地图片预览 整体实现 # 表单中的文件控件 multiple: 是否可以多选 accept: 设置默认筛选的格式 1&lt;input type=&quot;file&quot; multiple /&gt; 设置只显示图片 123456// 只允许看到jpeg图片&lt;input type=&quot;file&quot; accept=&quot;image/jpeg&quot; /&gt;// 只允许看到png图片&lt;input type=&quot;file&quot; accept=&quot;.png&quot; /&gt;// 允许所有的图片&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; /&gt; 其它类型 文件类型 accept 属性值 类型 *.3gpp audio/3gpp, video/3gpp 3GPP Audio/Video *.ac3 audio/ac3 AC3 Audio *.asf allpication/vnd.ms-asf Advanced Streaming Format *.au audio/basic AU Audio *.css text/css Cascading Style Sheets *.csv text/csv Comma Separated Values *.doc application/msword MS Word Document *.dot application/msword MS Word Template *.dtd application/xml-dtd Document Type Definition *.dwg image/vnd.dwg AutoCAD Drawing Database *.dxf image/vnd.dxf AutoCAD Drawing Interchange Format *.gif image/gif Graphic Interchange Format *.htm text/html HyperText Markup Language *.html text/html HyperText Markup Language *.jp2 image/jp2 JPEG-2000 *.jpe image/jpeg JPEG *.jpeg image/jpeg JPEG *.jpg image/jpeg JPEG *.js text/javascript, application/javascript JavaScript *.json application/json JavaScript Object Notation *.mp2 audio/mpeg, video/mpeg MPEG Audio/Video Stream, Layer II *.mp3 audio/mpeg MPEG Audio Stream, Layer III *.mp4 audio/mp4, video/mp4 MPEG-4 Audio/Video *.mpeg video/mpeg MPEG Video Stream, Layer II *.mpg video/mpeg MPEG Video Stream, Layer II *.mpp application/vnd.ms-project MS Project Project *.ogg application/ogg, audio/ogg Ogg Vorbis *.pdf application/pdf Portable Document Format *.png image/png Portable Network Graphics *.pot application/vnd.ms-powerpoint MS PowerPoint Template *.pps application/vnd.ms-powerpoint MS PowerPoint Slideshow *.ppt application/vnd.ms-powerpoint MS PowerPoint Presentation *.rtf application/rtf, text/rtf Rich Text Format *.svf image/vnd.svf Simple Vector Format *.tif image/tiff Tagged Image Format File *.tiff image/tiff Tagged Image Format File *.txt text/plain Plain Text *.wdb application/vnd.ms-works MS Works Database *.wps application/vnd.ms-works Works Text Document *.xhtml application/xhtml+xml Extensible HyperText Markup Language *.xlc application/vnd.ms-excel MS Excel Chart *.xlm application/vnd.ms-excel MS Excel Macro *.xls application/vnd.ms-excel MS Excel Spreadsheet *.xlt application/vnd.ms-excel MS Excel Template *.xlw application/vnd.ms-excel MS Excel Workspace *.xml text/xml, application/xml Extensible Markup Language *.zip application/zip Compressed Archive # 本地图片预览 html5 本地预览 文件控件选中图片后，文件控件中会保存图片信息它的 files 属性中。files 属性是一个数组，如果只选中了一张图片，这张图片就放在 files [0] 中，如选了多张图片，则类似后推。 对于这些文件信息（本例中的文件就是用户选中的图片），我们通过 window.URL.createObjectURL() 来创建一个临时的路径，这个路径可能是像这样： 1blob:http://localhost:3005/fc517910-1300-44f3-a6e8-d52f56f34e4e 你可以通过打一个新的浏览器窗口，并在地址栏中输入这个路径来访问这张图片。注意，它只是临时的，如果你关闭了选中图片的网页，这张图片也将会不可访问。 现在，我们拿到这个临时的 url 赋值给某一个 img 标签的 src 即可。 1234567891011// input_avatar就是file控件的内容发生变化执行$(&quot;#input_avatar&quot;).change(function () &#123; // console.log(&#x27;xxx&#x27;); // 如果没有选择文件，返回 if (!this.files[0]) return; var url = URL.createObjectURL(this.files[0]); // 设置图片的src $(&quot;#avatar&quot;).attr(&quot;src&quot;, url);&#125;); # 上传功能开发 这里的上传不是一个简单的 post 请求，它其中包含了文件的上传，在技术选型上我们选择了 html5 中的 FormData，并使用 jquery 中的 ajax 方法来实现上传操作。 这里要注意两点： processData:false 不需要 jquery 去处理上传数据 contentType:false jquery 会自动给 post 请求设置请求头，content-type:‘application-x-www-’。这种做法在大多数情况下，都是对的，但是，如果提交的数据是 formdata，就不需要去设置了。 1234567891011121314151617181920212223242526// 2. 添加会员// 2.1 给按钮注册事件 注意，这个是提交按钮$(&quot;#btn_add&quot;).click(function () &#123; // 2.2 获取用户输入的内容，还有用户选择的文件 // 2.3 FormData 设置请求体，可以提交二进制数据，可以上传文件 // xhr.send(formData); var fd = new FormData($(&quot;#myform&quot;)[0]); // 2.4 发送请求，添加数据 $.ajax(&#123; type: &quot;post&quot;, url: &quot;/member/add&quot;, data: fd, processData: false, // 不设置content-type，而是当设置了formdata上传文件的时候，xhr对象会自动把content-type设置为multipart/form-data; contentType: false, success: function (data) &#123; // 判断添加是否成功... // 2.5 跳转回首页 location.href = &quot;/&quot;; &#125;, &#125;); // 取消默认行为，不进行表单提交 return false;&#125;); 案例 3：在 jquery 中使用 FormData 123456789101112131415161718192021&lt;script src=&quot;./jquery-1.8.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;#btn&#x27;).click(function() &#123; // 收集用户信息 // var fd = new FormData(document.getElementById(&#x27;myForm&#x27;)); // FormData(必须是一个dom元素) （1） var fd = new FormData($(&#x27;#myForm&#x27;)[0]); console.info(fd); console.info(fd.get(&#x27;userPassword&#x27;)); $.ajax(&#123; url: &#x27;common/post&#x27;, type: &#x27;post&#x27;, data: fd, processData: false, // 不需要jquery去处理数据。 （2） contentType: false, // 不需要默认的contentType，而采用FormData自己的 （3） success: function(res) &#123; console.info(res); &#125; &#125;);&#125;);&lt;/script&gt; 注意：以上三个地方。 # 加载更多 测试接口 分析加载数据的时机 基本完成 1234567891011121314151617全局变量来记录最大的last值&#x2F;&#x2F; 注册滚动的事件$(window).scroll(function () &#123; &#x2F;&#x2F; 判断当前是否正在加载数据，如果正在加载数据，就不要再次发送请求了 if (loading) return; &#x2F;&#x2F; 获取文档的高度 var documentH &#x3D; $(document).height(); &#x2F;&#x2F; 获取浏览器窗口的高度 var windowH &#x3D; $(window).height(); &#x2F;&#x2F; 文档滚动出去的距离 var scrollTop &#x3D; $(document).scrollTop(); &#x2F;&#x2F; 判断当前滚动条距离底部的距离是否 &lt;&#x3D; 100，加载更多数据 if (documentH - windowH - scrollTop &lt;&#x3D; 100) &#123; &#x2F;&#x2F; 加载更多 loadData(); &#125;&#125;); 优化 不要重复发请求 loading 效果 数据全部加载完成之后的处理 # 模板引擎 目标： 理解模板引擎的作用； 会用模板引擎； # 作用 ​ 把数据生成页面，这个过程叫渲染。 [外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-SUJ5N7ko-1581995138737)(D:\\prepare\\fanyoufu\\01-ajax\\ 笔记 \\ 讲义.assets\\1558772178540.png)] 如果数据结构简单，可以直接通过字符串操作（拼接）的方式处理，但是如果数据过于复杂，字符串拼接维护成本太大，就不太适用，此时就可以使用模板引擎。模板引擎内部支持循环，选择，判断等高级的功能。 模板引擎： artTemplate：https://aui.github.io/art-template/ 中文教程：http://www.jq22.com/jquery-info1097 模板引擎实际上就是一个 API，模板引擎有很多种，使用方式大同小异，目的是更容易更高效地将数据渲染到 HTML 字符串中。 # 使用模板引擎步骤 引入 template-web.js 文件 定义模板（具体语法可以去官网查看），指定 script 的 id 和 type 属性 准备数据。(变量，数组等) 调用 template 函数，为模板分配数据，template 函数有两个参数一个返回值 参数 1：模板的 id 参数 2：分配的数据，必须是一个 JS 对象的形式 一个返回值：是数据和模板标签组合好的结果 将 “拼接” 好的结果放回 dom 容量中 123456789101112131415161718192021&lt;div id=&quot;content&quot;&gt; &lt;!-- 准备一个存放数据的位置 --&gt;&lt;/div&gt;&lt;!-- 1. 引入template-web.js --&gt;&lt;script src=&quot;/template-web.js&quot;&gt;&lt;/script&gt;&lt;!-- 2. 定义模板（注意script标签的id和type必须指定） --&gt;&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; &lt;h2&gt;&#123;&#123;data&#125;&#125;&lt;/h2&gt;&lt;/script&gt;&lt;script&gt; // 3. 替换模板 // test对应上面script标签的id // data对应上面script标签中使用的$data var html = template(&quot;test&quot;, &#123; data: &quot;hello world&quot;, &#125;); // 4. 将替换好的html放到指定位置 document.getElementById(&quot;content&quot;).innerHTML = html;&lt;/script&gt; 注意： 定义模板时的 script 标签一定好指定 id 和 type tempalte 函数语法： var html = template(模板id, Object) # 模板语法 # 输出普通数据（字符串，数值） 12345678&#x2F;&#x2F; 模块写法&#123;&#123; var &#125;&#125;&#x2F;&#x2F; template 函数写法var html &#x3D; template(&#39;id&#39;, &#123; var： &#39;hello world&#39;&#125;) # 条件 1234567891011// 模板写法&#123;&#123;if age &gt; 18&#125;&#125; 大于18&#123;&#123;else&#125;&#125; 小于18&#123;&#123;/if&#125;&#125;// template函数写法var html = template(&#x27;id&#x27;, &#123; age: 20&#125;); # 循环 12345678910111213141516&#x2F;&#x2F; 模板写法1&#123;&#123;each arr&#125;&#125; &#123;&#123;$index&#125;&#125; -- 数组的下标 &#123;&#123;$value&#125;&#125; -- 数组的值&#123;&#123;&#x2F;each&#125;&#125;&#x2F;&#x2F; 模板写法1&#123;&#123;each arr item idx&#125;&#125; &#123;&#123;idx&#125;&#125; -- 数组的下标 &#123;&#123;item&#125;&#125; -- 数组的值&#123;&#123;&#x2F;each&#125;&#125;&#x2F;&#x2F; template函数写法var html &#x3D; template(&#39;id&#39;, &#123; arr: [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;]&#125;);","categories":[],"tags":[{"name":"about","slug":"about","permalink":"http://example.com/tags/about/"}]},{"title":"Step.4 主题特殊功能","slug":"computer-science/note/theme-shoka-doc/special","date":"2020-08-13T13:45:48.000Z","updated":"2020-11-19T04:23:39.582Z","comments":true,"path":"2020/08/13/computer-science/note/theme-shoka-doc/special/","link":"","permalink":"http://example.com/2020/08/13/computer-science/note/theme-shoka-doc/special/","excerpt":"","text":"🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 以下介绍可以使用的 markdown 或者标签代码。 功能大部分基于 hexo-renderer-multi-markdown-it 渲染器，尤其是代码块的显示，与默认渲染器不兼容。 # links 链接块 本功能参考 NexT，基于 Hexo Tag 功能，用来建立友链或其他网址链接功能。 文章中的使用格式： 使用 links 标签块，包围 yml 语法书写的内容，字段包括 –|--|– site | 站点名称 | 必填 owner | 管理员名字 | 可选，默认为 site 的值 url | 站点链接 | 必填 desc | 站点描述 | 可选，默认为 url 的值 image | 站点图片 | 可选，默认为 images/404.png color | 方块颜色 | 可选，默认为 #666 12345678&amp;#123;% links %&amp;#125;- site: #站点名称 owner: #管理员名字 url: #站点网址 desc: #简短描述 image: #一张图片 color: #颜色代码&amp;#123;% endlinks %&amp;#125; 举个栗子： 123456789101112131415161718&amp;#123;% links %&amp;#125;- site: 優萌初華 owner: 霜月琉璃 url: https:&#x2F;&#x2F;shoka.lostyu.me desc: 琉璃的医学 &amp; 编程笔记 image: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;amehime&#x2F;shoka@latest&#x2F;images&#x2F;avatar.jpg color: &quot;#e9546b&quot;- site: 優萌初華 owner: 霜月琉璃 url: https:&#x2F;&#x2F;shoka.lostyu.me image: images&#x2F;avatar.jpg- site: 優萌初華 url: https:&#x2F;&#x2F;shoka.lostyu.me desc: 琉璃的医学 &amp; 编程笔记 color: &quot;#9d5b8b&quot;&amp;#123;% endlinks %&amp;#125; 優萌初華 琉璃的医学 & 编程笔记 優萌初華 https://shoka.lostyu.me 優萌初華 琉璃的医学 & 编程笔记 以上标签块里的内容，还可以保存到一个 yml 文件中，然后使用 linksfile 标签。 其中， path 位于 &lt;root&gt;/source 目录下。 1&amp;#123;% linksfile [path] %&amp;#125; 举个栗子： 1&amp;#123;% linksfile friends&#x2F;_data.yml %&amp;#125; # code 代码块 使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。 基本格式： [language] [title] [url] [link text] [mark] [command] 选项 描述 默认值 language - 支持的语言戳此 null \\ - 如果不需要代码高亮，但希望显示代码块样式，则设为 raw \\ - 留空或设为 info ，将不显示代码高亮和代码块样式 title 代码块的标题文字 null url 代码块标题右侧显示的链接 null link text 上述链接显示的标题 link mark 行高亮显示，格式为 mark:行号,行号开始-行号结束,其他行号 。 null \\ 例如 mark:1,4-7,10 ，将高亮显示第 1、4、5、6、7、10 行 command 命令行提示符，格式为 command:(&quot;提示内容&quot;:行号,行号||&quot;提示内容&quot;:行号开始-行号结束) null \\ 例如 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6) 1234567891011121314151617181920212223&#96;&#96;&#96;java 行高亮 https:&#x2F;&#x2F;shoka.lostyu.me 参考链接 mark:1,6-7import java.util.Scanner;...Scanner in &#x3D; new Scanner(System.in);&#x2F;&#x2F; 输入Scan之后，按下键盘 Alt + “&#x2F;” 键，Eclipse下自动补全。System.out.println(in.nextLine());System.out.println(&quot;Hello&quot; + &quot; world.&quot;);&#96;&#96;&#96;&#96;&#96;&#96;bash 命令行提示符 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6)pwd&#x2F;usr&#x2F;home&#x2F;chris&#x2F;binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push&#96;&#96;&#96; 行高亮参考链接 mark:1,6-71234567import java.util.Scanner;...Scanner in = new Scanner(System.in);// 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。System.out.println(in.nextLine());System.out.println(&quot;Hello&quot; + &quot; world.&quot;); 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1234567891011pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push # quiz 练习题与答案 这个功能是用来显示练习题的。 需要在 Front Matter 中添加 quiz: true ，以正确显示题型标签。 几个例子12345678910111213141516171819202122232425262728293031323334---title: 练习题与答案quiz: true---1. 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 &#123;.quiz .true&#125;2. 有基类&#96;SHAPE&#96;，派生类&#96;CIRCLE&#96;，声明如下变量： &#123;.quiz .multi&#125; &#96;&#96;&#96;cpp SHAPE shape1,*p1; CIRCLE circle1,*q1; &#96;&#96;&#96; 下列哪些项是“派生类对象替换基类对象”。 - &#96;p1&#x3D;&amp;circle1;&#96; &#123;.correct&#125; - &#96;q1&#x3D;&amp;shape1;&#96; - &#96;shape1&#x3D;circle1;&#96; &#123;.correct&#125; - &#96;circle1&#x3D;shape1;&#96;&#123;.options&#125; &gt; - :heavy_check_mark: 令基类对象的指针指向派生类对象 &gt; - :x: 派生类指针指向基类的引用 &gt; - :heavy_check_mark: 派生类对象给基类对象赋值 &gt; - :x: 基类对象给派生类对象赋值 &gt; &#123;.options&#125;3. 下列叙述正确的是 []&#123;.gap&#125; 。 &#123;.quiz&#125; - 虚函数只能定义成无参函数 - 虚函数不能有返回值 - 能定义虚构造函数 - A、B、C都不对 &#123;.correct&#125;&#123;.options&#125;10. 如果定义&#96;int e&#x3D;8; double f&#x3D;6.4, g&#x3D;8.9;&#96;，则表达式 &#96;f+int(e&#x2F;3*int(f+g)&#x2F;2)%4&#96; 的值为 [9.4]&#123;.gap&#125;。 &#123;.quiz .fill&#125; &gt; 注意运算顺序和数据类型 &gt; [8.4]&#123;.mistake&#125; 点击选项可以显示答案，以及答案解析。 下列叙述正确的是 。 虚函数只能定义成无参函数 虚函数不能有返回值 能定义虚构造函数 A、B、C 都不对 有基类 SHAPE ，派生类 CIRCLE ，声明如下变量： 12SHAPE shape1,*p1;CIRCLE circle1,*q1; 下列哪些项是 “派生类对象替换基类对象”。 p1=&amp;circle1; q1=&amp;shape1; shape1=circle1; circle1=shape1; ✔️ 令基类对象的指针指向派生类对象 ❌ 派生类指针指向基类的引用 ✔️ 派生类对象给基类对象赋值 ❌ 基类对象给派生类对象赋值 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 如果定义 int e=8; double f=6.4, g=8.9; ，则表达式 f+int(e/3*int(f+g)/2)%4 的值为 9.4。 注意运算顺序和数据类型 8.4 # 使用说明 本功能基于 markdown-it-bracketed-spans 和 markdown-it-attrs 标签 含义 &#123;.quiz&#125; 选择题 &#123;.quiz .multi&#125; 多选题 &#123;.quiz .true&#125; 正确的判断题 &#123;.quiz .false&#125; 错误的判断题 &#123;.quiz .fill&#125; 填空题 []&#123;.gap&#125; 空白下划线 [答案内容]&#123;.gap&#125; 答案内容带下划线 &#123;.options&#125; ABCDE 选项 &#123;.correct&#125; 选择题的正确选项 &gt; 答案解析 [8.4]&#123;.mistake&#125; 错题备注 # emoji 绘文字 本功能基于 markdown-it-emoji ，所有标签参考戳此 123:kissing_heart::ring::notes: 😘 💍 🎶 # effects 文字特效 本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger 12345678910111213141516171819202122++下划线++++波浪线++&#123;.wavy&#125;++着重点++&#123;.dot&#125;++紫色下划线++&#123;.primary&#125;++绿色波浪线++&#123;.wavy .success&#125;++黄色着重点++&#123;.dot .warning&#125;~~删除线~~~~红色删除线~~&#123;.danger&#125;&#x3D;&#x3D;荧光高亮&#x3D;&#x3D;[赤橙黄绿青蓝紫]&#123;.rainbow&#125;[红色]&#123;.red&#125;[粉色]&#123;.pink&#125;[橙色]&#123;.orange&#125;[红色]&#123;.yellow&#125;[绿色]&#123;.green&#125;[靛青]&#123;.aqua&#125;[蓝色]&#123;.blue&#125;[紫色]&#123;.purple&#125;[灰色]&#123;.grey&#125;快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;H~2~029^th^ 这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。 正确的代码是 ++下划线++ ~~删除线~~ ==荧光高亮== ，不能有空格哦。 下划线 波浪线 着重点 紫色下划线 绿色波浪线 黄色着重点 删除线 红色删除线 荧光高亮 赤橙黄绿青蓝紫 红色 粉色 橙色 黄色 绿色 靛青 蓝色 紫色 灰色 快捷键 Ctrl + C H20 29th # spoiler 隐藏文字 本功能基于 markdown-it-spoiler 和 markdown-it-attrs 12!!黑幕黑幕黑幕黑幕黑幕黑幕!! ： 鼠标滑过显示内容!!模糊模糊模糊模糊模糊模糊!!&#123;.bulr&#125; ： 选中文字显示内容 黑幕黑幕黑幕黑幕黑幕黑幕 ： 鼠标滑过显示内容 模糊模糊模糊模糊模糊模糊 ： 选中文字显示内容 # label 标签块 本功能基于 markdown-it-bracketed-spans 和 markdown-it-attrs 有以下颜色可选 123456[default]&#123;.label&#125;[primary]&#123;.label .primary&#125;[info]&#123;.label .info&#125;[:heavy_check_mark:success]&#123;.label .success&#125;[warning]&#123;.label .warning&#125;[:broken_heart:danger]&#123;.label .danger&#125; default primary info ✔️success warning 💔danger # note 提醒块 本功能基于 markdown-it-container 标签为： –|-- 开始行 | :::[风格颜色] 结束行 | ::: 123456789101112131415161718192021222324252627:::default默认默认::::::primary基本基本::::::info提示提示::::::success成功成功::::::warning警告警告::::::danger危险危险::::::danger no-icon危险危险::: 默认默认 基本基本 提示提示 成功成功 警告警告 危险危险 没有图标 # tab 标签卡 本功能基于 markdown-it-container 标签为： –|-- 开始行 | ;;;[同一ID] [标签名称] 结束行 | ;;; 12345678910111213141516171819202122232425262728293031;;;id1 卡片1这里是卡片1的内容**加粗**[success]&#123;.label .success&#125;&amp;#123;% links %&amp;#125;- site: 優萌初華 owner: 霜月琉璃 url: https:&#x2F;&#x2F;shoka.lostyu.me desc: 琉璃的医学 &amp; 编程笔记 image: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;amehime&#x2F;shoka@latest&#x2F;images&#x2F;avatar.jpg color: &quot;#e9546b&quot;&amp;#123;% endlinks %&amp;#125;;;;;;;id1 卡片2这里是卡片2的内容:::danger危险危险:::- 第一行- 第二行;;;;;;id2 ②号标签卡片1这里是卡片1的内容;;;;;;id2 ②号标签卡片2这里是卡片2的内容;;; 这里是卡片 1 的内容 加粗 success 優萌初華 琉璃的医学 & 编程笔记 这里是卡片 2 的内容 危险危险 第一行 第二行 这里是卡片 1 的内容 这里是卡片 2 的内容 # collapse 折叠块 本功能基于 markdown-it-container 标签为： –|-- 开始行 | +++[风格颜色] [标题文字] 结束行 | +++ 1234567891011121314151617181920212223242526272829303132333435363738394041+++ 默认默认 这里是一段文字++下划线++++++++primary 紫色:::info参考信息:::- 第一行- 第二行++++++info 蓝色;;;id3 卡片1这里是卡片1的内容;;;;;;id3 卡片2这里是卡片2的内容;;;++++++success 绿色&amp;#123;% links %&amp;#125;- site: 優萌初華 url: https:&#x2F;&#x2F;shoka.lostyu.me color: &quot;#e9546b&quot;&amp;#123;% endlinks %&amp;#125;++++++warning 黄色!!警告警告警告警告警告!!&#123;.bulr&#125;[label]&#123;.label .success&#125;++++++danger 红色[danger]&#123;.label .danger&#125;+++ 默认默认 这里是一段文字 下划线 紫色 参考信息 第一行 第二行 蓝色 这里是卡片 1 的内容 波浪线 这里是卡片 2 的内容 绿色 優萌初華 https://shoka.lostyu.me 黄色 警告警告警告警告警告 label 红色 danger # taskList 待办事项 本功能基于 markdown-it-task-checkbox 。 可以利用 markdown-it-attrs 添加风格颜色，只可以给 ul 标签添加，需要新建两行。 123456789101112- [ ] 这是一个小叉叉- [x] 这是一个红色勾勾&#123;.danger&#125;- [ ] 未完成- [x] 完成&#123;.primary&#125;- [ ] 未完成- [x] 默认颜色 这是一个小叉叉 这是一个红色勾勾 未完成 完成 未完成 默认颜色 # furigana 文字注音 原本用于日语汉字假名注音，但别的注音也可以。 为了兼容性，采用 markdown-it-ruby 的基本格式： &#123;文字^注音&#125; ，并且为了兼容表格，将分隔符由 | 换成了 ^ 。 注音分隔基于 furigana-markdown-it 显示说明看这里 –|-- &#123;取り返す^とりかえす&#125; | 取【と】り返【かえ】す &#123;可愛い犬^か+わい・い・いぬ&#125; | 可愛【かわい】い犬【いぬ】 &#123;可愛い犬^か・わい・いいぬ&#125; | 可【か】愛【わい】い犬【いぬ】 &#123;アクセラレータ^accelerator&#125; | アクセラレータ【accelerator】 &#123;accelerator^アクセラレータ&#125; | accelerator【アクセラレータ】 &#123;食べる^たべる&#125; | 食【た】べる &#123;食べる^=たべる&#125; | 食べる【たべる】 &#123;あいうえお^*&#125; | あ●い●う●え●お● &#123;あいうえお^*❤&#125; | あ❤い❤う❤え❤お❤ &#123;常用账号^contact&#125; | 常用账号【contact】 # media 多媒体 本功能基于 Hexo Tag 功能，使用 media 标签，目前可选择两种类型，即 audio 和 video 。 1234567&amp;#123;% media audio %&amp;#125;...音频列表&amp;#123;% endmedia %&amp;#125;&amp;#123;% media video %&amp;#125;...视频列表&amp;#123;% endmedia %&amp;#125; 标签包绕一段 yml 格式的内容，格式与背景音乐的配置类似。 亦可以直接使用网易云、虾米、QQ 音乐的播放列表、单曲。 举个栗子1234567891011121314151617&amp;#123;% media audio %&amp;#125;- title: 列表1 list: - https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;playlist?id&#x3D;2943811283 - https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;playlist?id&#x3D;2297706586- title: 列表2 list: - https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;playlist?id&#x3D;2031842656&amp;#123;% endmedia %&amp;#125;&amp;#123;% media video %&amp;#125;- name: &quot;测试1&quot; url: https:&#x2F;&#x2F;cdn.kastatic.org&#x2F;ka-youtube-converted&#x2F;O_nY1TM2RZM.mp4&#x2F;O_nY1TM2RZM.mp4#t&#x3D;0- name: &quot;测试2&quot; url: https:&#x2F;&#x2F;cdn.kastatic.org&#x2F;ka-youtube-converted&#x2F;O_nY1TM2RZM.mp4&#x2F;O_nY1TM2RZM.mp4#t&#x3D;0&amp;#123;% endmedia %&amp;#125; # math 数学公式 本功能基于 markdown-it-katex 在 Front Matter 中添加 math: true 以支持 KaTex 123456789101112131415161718---title: 数学公式显示math: true---行内公式：$\\sqrt&#123;3x-1&#125;+(1+x)^2$独立块显示：$$\\begin&#123;array&#125;&#123;c&#125;\\nabla \\times \\vec&#123;\\mathbf&#123;B&#125;&#125; -\\, \\frac1c\\, \\frac&#123;\\partial\\vec&#123;\\mathbf&#123;E&#125;&#125;&#125;&#123;\\partial t&#125; &amp;&#x3D; \\frac&#123;4\\pi&#125;&#123;c&#125;\\vec&#123;\\mathbf&#123;j&#125;&#125; \\nabla \\cdot \\vec&#123;\\mathbf&#123;E&#125;&#125; &amp; &#x3D; 4 \\pi \\rho \\\\\\nabla \\times \\vec&#123;\\mathbf&#123;E&#125;&#125;\\, +\\, \\frac1c\\, \\frac&#123;\\partial\\vec&#123;\\mathbf&#123;B&#125;&#125;&#125;&#123;\\partial t&#125; &amp; &#x3D; \\vec&#123;\\mathbf&#123;0&#125;&#125; \\\\\\nabla \\cdot \\vec&#123;\\mathbf&#123;B&#125;&#125; &amp; &#x3D; 0\\end&#123;array&#125;$$ 行内公式：3x−1+(1+x)2\\sqrt{3x-1}+(1+x)^23x−1​+(1+x)2 独立块显示： ∇×B⃗− 1c ∂E⃗∂t=4πcj⃗∇⋅E⃗=4πρ∇×E⃗ + 1c ∂B⃗∂t=0⃗∇⋅B⃗=0\\begin{array}{c} \\nabla \\times \\vec{\\mathbf{B}} -\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} &amp; = \\frac{4\\pi}{c}\\vec{\\mathbf{j}} \\nabla \\cdot \\vec{\\mathbf{E}} &amp; = 4 \\pi \\rho \\\\ \\nabla \\times \\vec{\\mathbf{E}}\\, +\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t} &amp; = \\vec{\\mathbf{0}} \\\\ \\nabla \\cdot \\vec{\\mathbf{B}} &amp; = 0 \\end{array}∇×B−c1​∂t∂E​∇×E+c1​∂t∂B​∇⋅B​=c4π​j​∇⋅E=0=0​=4πρ # mermaid 流程图 本功能基于 markdown-it-mermaid 在 Front Matter 中添加 mermaid: true 以支持 Mermaid 12345678910111213141516171819202122232425262728---title: 流程图显示mermaid: true---&#96;&#96;&#96;mermaidgraph LR A[Square Rect] -- Link text --&gt; B((Circle)) A --&gt; C(Round Rect) B --&gt; D&#123;Rhombus&#125; C --&gt; D&#96;&#96;&#96;&#96;&#96;&#96;mermaidsequenceDiagram loop Daily query Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end end&#96;&#96;&#96; 12345graph LR A[Square Rect] -- Link text --&gt; B((Circle)) A --&gt; C(Round Rect) B --&gt; D&#123;Rhombus&#125; C --&gt; D 12345678910111213sequenceDiagram loop Daily query Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end end","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Step.3 界面显示","slug":"computer-science/note/theme-shoka-doc/display","date":"2020-08-13T13:12:48.000Z","updated":"2020-11-19T04:23:39.580Z","comments":true,"path":"2020/08/13/computer-science/note/theme-shoka-doc/display/","link":"","permalink":"http://example.com/2020/08/13/computer-science/note/theme-shoka-doc/display/","excerpt":"","text":"🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 # 首页置顶文章 在文章的 Front Matter 设置 sticky: true ，则该文章将显示在首页最上方的 置顶文章 列。 多篇文章按照发布时间倒序排列，不分页。 1234---title: 置顶文章sticky: true--- # 首页精选分类 想要在首页显示分类翻转块，需要按照以下示例的方式，给需要显示的分类加上封面图。 首先，修改站点配置： 找到 category_map: ，配置每个分类对应的英文映射，比如： 12345678category_map: 计算机科学: computer-science Java: java C++: cpp 二进制杂谈: note 计算机程序设计（C++）-西安交通大学: course-1 零基础学Java语言-浙江大学-翁恺: course-1 面向对象程序设计-Java语言-浙江大学-翁恺: course-2 注意：hexo 会自动处理路径中的特殊字符，~`!@#$%^&amp;*()-_+={}|\\;:&quot;’&lt;&gt;,.? 以及空格，这些全部会被替换成 - 所以避免在设置中使用上述字符，否则可导致无法抓取到目录下的 cover.jpg 在 &lt;root&gt;/source/_posts 文件夹相应的目录里，存放封面图 例子：如 第 1 周 计算 这篇文章。 所处的分类是 12categories:- [计算机科学, Java, 零基础学Java语言-浙江大学-翁恺] 现在需要在首页显示 零基础学Java语言-浙江大学-翁恺 这个分类，翻转卡片后，显示这个分类下的文章们。 而该分类经过英文映射，它的路径将是 /computer-science/java/course-1/ 。 那么，请在 &lt;root&gt;/source/_posts/computer-science/java/course-1/ 的目录下放置 cover.jpg 文件。 只要 分类路径 对应的目录下存在 cover.jpg 文件，这个分类就会在首页显示。 在进行 hexo g 时，本分类的封面图会自动被复制到 public 目录里相应的位置。 事实上，为了方便文章管理，这个分类下所有文章的 md 文件，我都会放在 &lt;root&gt;/source/_posts/computer-science/java/course-1/ 这个目录下。 且站点配置文件里，永久链接设置如下 1permalink: :title/ hexo g 后，文章的 html 文件们将全部生成到 &lt;root&gt;/public/computer-science/java/course-1/ 目录。 具体可以查看本博客的 github 仓库。 文章详情界面中的 系列文章 ，显示的是与当前文章同一分类的其他文章，并按照文章名正序排序。 o (*￣▽￣*) ゞ 其实，不设置 category_map 也可以，只要在分类路径对应的文件夹下存在 cover.jpg 文件就行。 现在，这项功能与 category_dir 的配置也无关， hexo g 生成后，图片会自动被转移到 category_dir 的相关子目录下。 # 文章封面图 如果文章的 Front Matter 设置了 cover: image path ，则封面会显示这张图片。 举个栗子12345title: Imagescover: assets/wallpaper-2572384.jpg# 或者写成cover: http://placehold.it/350x150.jpg--- 这里 cover 的值可以是位于 source 目录里的图片文件，此处是 &lt;root&gt;/source/assets/wallpaper-2572384.jpg 文件，也可以是一个某网址。 如果文章是一个 gallery post ，即 Front Matter 设置了 photos ，则会封面会显示设置的第一张图片。 举个栗子1234567title: Gallery Postphotos:- assets/wallpaper-2572384.jpg- assets/wallpaper-2311325.jpg- assets/wallpaper-878514.jpg- http://placehold.it/350x150.jpg--- 此时默认会显示第一个图片，即位于 &lt;root&gt;/source/assets/ 目录里的 wallpaper-2572384.jpg 。 如果站点配置中设置了 post_asset_folder: true ，那么上述本地图片路径应为 &lt;root&gt;/source/_posts/文章同名的文件夹/assets/wallpaper-2572384.jpg ，当然此时 assets 目录可以省掉。 如果以上设置均不存在，将显示一张随机图片，随机图库配置戳此。 # 图片展示与相册 在文章的 Front Matter 设置 fancybox: false ，可以关闭文章页的图片展示功能。 使用 Justified-Gallery 对 Gallery Post 内图案进行排列。 下面介绍一些小技巧： 让图案下方显示 title 的 markdown 代码 1![这里是alt](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gicis081o9j20zk0m8dmr.jpg &quot;这里是title&quot;) 除了在 Front Matter 里配置 photos 可以显示相册图案列表外，还可以这样写 12345678910111213## 图案列表No.1![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg &quot;这里是title&quot;)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclflwv2aj20zk0m84qp.jpg)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclg5ms2rj20zk0m8u0x.jpg)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclhnx9glj20zk0m8npd.jpg)&#123;.gallery&#125;## 图案列表No.2![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gicitht3xtj20zk0m8k5v.jpg)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1giclil3m4ej20zk0m8tn8.jpg)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gicljgocqbj20zk0m8e81.jpg)![](https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;large&#x2F;6833939bly1gipetfk5zwj20zk0m8e81.jpg)&#123;.gallery data-height&#x3D;&quot;220&quot;&#125; data-height 用来设置每行的高度，默认为 120 # 图案列表 No.1 # 图案列表 No.2 # 自定义页面配色 主题配色全部在 &lt;root&gt;/themes/shoka/source/css/_colors.styl 文件中，可以自行查看。 在 &lt;root&gt;/source/_data/ 目录新建文件 colors.styl ，在此文件中添改样式。 自定义 colors.styl 文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。 主题支持在 &lt;root&gt;/source/_data/ 目录建立三个自定义 styl 文件： 自定义文件名 对应默认样式文件 样式功能 colors.styl _colors.styl 页面配色 iconfont.styl _iconfont.styl 图标样式 custom.styl - 任意自定义样式 # 自定义主题图片 如果想要修改主题的 &lt;root&gt;/themes/shoka/source/images/ 目录内的某张图片，请在 &lt;root&gt;/source/_data/ 目录新建目录 images ，并在这个文件夹中添加同名文件，部署时将自动覆盖主题内的默认图片。 可以用此方法自定义头像、打赏二维码等图片，并且避免覆盖更新主题时遗失自定义文件。 # 自定义语言包 本功能参考 NexT，主要可以用来定义菜单等处显示的文字，且可以方便主题无脑覆盖升级。 在 &lt;root&gt;/source/_data/ 目录新建文件 languages.yml 。 按照以下格式添加配置项： 12345678910# languagezh-CN: # items post: copyright: # the translation you perfer author: 本文博主en: menu: travellings: Travellings 可以参考主题目录下的 example/source/_data 文件夹。 站点配置及文件的 Front Matter 中， language 项只支持 zh-CN 、 zh-HK 、 zh-TW 、 ja 、 en 。 类似写成 zh_CN 这样是不可以的。","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Step.2 基本配置","slug":"computer-science/note/theme-shoka-doc/config","date":"2020-08-13T12:56:48.000Z","updated":"2020-11-19T04:23:39.577Z","comments":true,"path":"2020/08/13/computer-science/note/theme-shoka-doc/config/","link":"","permalink":"http://example.com/2020/08/13/computer-science/note/theme-shoka-doc/config/","excerpt":"","text":"🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 # 站点别称 1alternate: Yume Shoka 这里设置的名称代替 Logo，显示在页面顶部，以及页尾©️处 # 静态文件目录 1statics: / #//cdn.jsdelivr.net/gh/amehime/shoka@latest/ 默认值是 / ，指使用本地静态文件 可以修改成 //cdn.jsdelivr.net/gh/您的github用户名/您的项目名@latest/ 这种形式，以使用 jsDelivr 进行加速。 PS：jsDelivr 并不是实时更新，重新生成文件后需要耐心等待 123css: cssjs: jsimages: images 静态文件所处目录的实际目录名，这些一般不改。 # 夜间模式 1darkmode: # true 默认情况下，是否开启夜间模式取决于（优先级从高到低）： 访客点击页面头部切换按钮的自行选择 访客切换了浏览设备的主题色调 您的 darkmode 配置项 # 自动定位 1auto_scroll: # false 默认情况下，再次打开页面时，会自动滚动到上次浏览的位置。 这个选项设为 false 时将停用此功能。 # 加载动画 1234# 是否显示页面加载动画loading-catloader: start: true # 当初次打开页面时，显示加载动画 switch: true # tab切换到其他页面时，显示加载动画 tab 切换后只是显示 loading 动画，实际并未重新加载页面 # 页面特效 单击页面的烟花效果配置如下 1234567fireworks: enable: true # 是否启用 color: # 烟花颜色 - &quot;rgba(255,182,185,.9)&quot; - &quot;rgba(250,227,217,.9)&quot; - &quot;rgba(187,222,214,.9)&quot; - &quot;rgba(138,198,209,.9)&quot; # 加载谷歌字体 12345678910111213141516171819202122232425262728293031323334353637383940font: enable: true # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside &lt;body&gt;. global: external: true family: Mulish size: # Font settings for alternate title. logo: external: true family: Fredericka the Great size: 3.5 # Font settings for site title. title: external: true family: Noto Serif JP size: 2.5 # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;). headings: external: true family: Noto Serif SC size: # Font settings for posts. posts: external: true family: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Inconsolata 此功能基本参考 NexT。 加粗标题的字体总是使用 Noto Serif ，为了正确友好的显示日文中的汉字，会先后加载 headings 和 title 的字体设置。 # iconfont 图标 主题没有直接使用 Font Awesome，是因为用不到那么多 icon 感觉非常浪费，因此在 Iconfont 上重新建立了一个项目。 font-family 设为 ic ，所有字体样式前缀为 i- ，具体参见 &lt;root&gt;/themes/shoka/source/css/_iconfont.styl 。 123# project of https://www.iconfont.cn/# //at.alicdn.com/t/font_1832207_c8i9n1ulxlt.css =&gt; 1832207_c8i9n1ulxlticonfont: &quot;1832207_c8i9n1ulxlt&quot; 如果需要添加或修改，请留言告诉我您的 Iconfont 用户名，我将把您添加到目前的项目中。 添加权限为 只读 ，此后您可以任意全选，批量保存到购物车中，添加至您自己的项目里，并将主题配置文件中的 iconfont 值改为您的项目。 注意，您的项目应设置 FontClass/Symbol 前缀 为 i- 。 在 &lt;root&gt;/source/_data/ 目录新建文件 iconfont.styl ，把新增或修改的图标样式复制到这个文件中。 自定义 iconfont.styl 文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。 # 菜单与社交按钮 1234567891011121314151617181920212223242526menu: home: / || home about: /about/ || user posts: default: / || feather archives: /archives/ || list-alt categories: /categories/ || th tags: /tags/ || tags # friends: /friends/ || heart # links: /links/ || magicsocial: github: https://github.com/yourname || github || &quot;#191717&quot; #google: https://plus.google.com/yourname || google twitter: https://twitter.com/yourname || twitter || &quot;#00aff0&quot; zhihu: https://www.zhihu.com/people/yourname || zhihu || &quot;#1e88e5&quot; music: https://music.163.com/#/user/home?id=yourid || cloud-music || &quot;#e60026&quot; weibo: https://weibo.com/yourname || weibo || &quot;#ea716e&quot; about: https://about.me/yourname || address-card || &quot;#3b5998&quot; #email: mailto:yourname@mail.com || envelope || &quot;#55acd5&quot; #facebook: https://www.facebook.com/yourname || facebook #stackoverflow: https://stackoverflow.com/yourname || stack-overflow #youtube: https://youtube.com/yourname || youtube #instagram: https://instagram.com/yourname || instagram #skype: skype:yourname?call|chat || skype #douban: https://www.douban.com/people/yourname/ || douban 如上，使用 || 作为分隔符，依次为 链接 || 图标 || 颜色 。 注意，只需要写图标名称，如 github ，则会自动转换为 ic i-github 。 十六进制颜色码需要 &quot;&quot; 包绕。 menu 支持一级子目录，子目录设置中的第一项必须为 default ，用来定义父级按钮的样式。 菜单显示文字可以在语言包中定义，具体请戳这里 # 边栏配置 边栏可以选择在左侧，或右侧 修改头像文件的地址，相对于静态文件目录 images 中配置的路径。 123456sidebar: # Sidebar Position. position: left #position: right # Replace the default avatar image and set the url here. avatar: avatar.jpg 可以将自己的图片放在 &lt;root&gt;/source/_data/images/ 目录，甚至以同名覆盖主题内默认的头像图片，具体请戳这里 # 底部 widgets 目前页面底部可以显示两个小部件，即 随机文章 和 最近评论 。 123widgets: random_posts: true # 显示随机文章 recent_comments: true # 显示最近评论 # 字数及阅读时间统计 安装好 hexo-symbols-count-time 插件后，不需要修改站点配置文件，直接使用插件默认配置就行。 需要修改主题配置文件，找到两处 cout ，修改为 true ： 12345678# 页尾全站统计footer: since: 2010 count: true# 文章界面统计post: count: true # 文章评论 如何获取 LeanCloud 的 appId 和 appKey。 1234567891011121314151617181920212223242526272829valine: appId: #Your_appId appKey: #Your_appkey placeholder: ヽ(○´∀`)ﾉ♪ # Comment box placeholder avatar: mp # Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro pageSize: 10 # Pagination size lang: zh-CN visitor: true # 文章访问量统计 NoRecordIP: false # 不记录IP serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in) powerMode: true # 默认打开评论框输入特效 tagMeta: visitor: 新朋友 master: 主人 friend: 小伙伴 investor: 金主粑粑 tagColor: master: &quot;var(--color-orange)&quot; friend: &quot;var(--color-aqua)&quot; investor: &quot;var(--color-pink)&quot; tagMember: master: # - hash of master@email.com # - hash of master2@email.com friend: # - hash of friend@email.com # - hash of friend2@email.com investor: # - hash of investor1@email.com tag 标签显示在评论者名字的后面，默认是 tagMeta.visitor 对应的值。 在 tagMeta 和 tagColor 中，除了 visitor 这个 key 不能修改外，其他 key 都可以换一换，但需要保证一致性。 举个栗子12345678910111213tagMeta: visitor: 游客 admin: 管理员 waifu: 我老婆tagColor: visitor: &quot;#855194&quot; admin: &quot;#a77c59&quot; waifu: &quot;#ed6ea0&quot;tagMember: admin: # - hash of admin@email.com waifu: # - hash of waifu@email.com 在文章 Front Matter 中也可以配置上述参数，访问该文章页面时，将覆盖全局配置。 尤其可以用来配置一个特殊的 placeholder。 123valine: placeholder: &quot;1. 提问前请先仔细阅读本文档⚡\\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪&quot;--- 评论通知与管理工具建议使用这个 Valine-Admin。 注意 SITE_URL 需要以 / 结尾。 如果某一篇文章需要关闭评论功能，则在文章 Front Matter 中配置： 1234---title: 关闭评论comment: false--- # 背景音乐 在主题配置文件中，设置全局播放列表。 在文章的 Front Matter 中，设置文章专有播放列表，访问该文章页面时，将覆盖全局配置。 单列表12345audio: - https://music.163.com/song?id=1387098940 - https://music.163.com/#/playlist?id=2088001742 - https://www.xiami.com/collect/250830668 - https://y.qq.com/n/yqq/playsquare/3535982902.html 如上，可以直接使用网易云、虾米、QQ 音乐的播放列表、单曲，可以同时填写多个。 多列表12345678audio: - title: 列表1 list: - https://music.163.com/#/playlist?id=2943811283 - https://music.163.com/#/playlist?id=2297706586 - title: 列表2 list: - https://music.163.com/#/playlist?id=2031842656 如果需要自定义媒体文件，可以按照以下格式填写： 单列表1234567891011audio: - name: &quot;曲目1&quot; url: &quot;播放地址&quot; artist: &quot;艺术家&quot; cover: &quot;封面&quot; lrc: &quot;歌词&quot; - name: &quot;曲目2&quot; url: &quot;播放地址&quot; artist: &quot;艺术家&quot; cover: &quot;封面&quot; lrc: &quot;歌词&quot; 多列表12345678910111213141516audio: - title: 列表1 list: - name: &quot;曲目1&quot; url: &quot;播放地址&quot; artist: &quot;艺术家&quot; cover: &quot;封面&quot; lrc: &quot;歌词&quot; - name: &quot;曲目2&quot; url: &quot;播放地址&quot; artist: &quot;艺术家&quot; cover: &quot;封面&quot; lrc: &quot;歌词&quot; - title: 列表2 list: - https://music.163.com/#/playlist?id=2031842656 如果要关闭当前页面的背景音乐播放器，则在文章 Front Matter 中配置： 1234---title: 关闭背景音乐audio: false--- # 随机图库 默认的图片列表位于 &lt;root&gt;/themes/shoka/_images.yml 中。 使用了渣浪图库，使用一些上传工具，比如这里 上传后图片的链接是 http://wx4.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg 。 只需要新一行写上 - 6833939bly1gicmnywqgpj20zk0m8dwx.jpg 。 如果想要自定义，则在 &lt;root&gt;/source/_data/ 目录新建一个 images.yml 文件，这个文件中的图片至少 6 枚，将完全覆盖默认的图片列表。 也可以直接在图片列表 yml 文件中，写上任意外链图片地址 12345- https://i.loli.net/2020/10/30/qAMYEFXxJcKRsiG.gif- https://i.loli.net/2020/10/30/rjdhcSgEN8COBPA.jpg- https://i.loli.net/2020/10/30/HKyzSd7NI3mlBpt.jpg- https://i.loli.net/2020/10/30/Y1CBXqgeokEs457.jpg- https://i.loli.net/2020/10/30/Z5W6r2BSoiThHG1.jpg 也可以在主题配置文件中，设置图床 API： 比如1image_server: &quot;https://acg.xydwz.cn/api/api.php&quot; # 加载第三方组件 12345vendors: css: # 略略略 js: # 略略略 包括 –|--|– pace | 加载进度条 | 全局 pjax | 页面无刷新加载 | 全局 anime | js 动画效果 | 全局 algolia instantsearch | 基于 algolia 的站内搜索 | 全局 lazyload | 图片懒加载 | 全局 quicklink | 链接资源预加载 | 全局 fetch | 获取播放列表 | 全局 katex copy_tex | 数学公式显示及复制 | 按需 fancybox | 图片放大显示及排列 | 按需 valine | 基于 LeanCloud 的评论系统及文章阅读次数统计 | 按需 chart | 图表显示 | 按需 以上文件加载全部基于 jsDelivr，并对全局加载的组件进行了文件合并。 如果不明白啥意思，则不要轻易修改。 主题版本升级的时候，可能会修改这里。 如果修改过主题默认 _config.yml ，记得更新主题时，末尾的 vendors 也要及时修改。","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Step.1 依赖插件","slug":"computer-science/note/theme-shoka-doc/dependents","date":"2020-08-13T12:46:48.000Z","updated":"2020-11-19T04:23:39.577Z","comments":true,"path":"2020/08/13/computer-science/note/theme-shoka-doc/dependents/","link":"","permalink":"http://example.com/2020/08/13/computer-science/note/theme-shoka-doc/dependents/","excerpt":"","text":"🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 请务必将 hexo-renderer-multi-markdown-it 升级到最新版，目前为 0.1.5 Theme Shoka 依赖以下 Hexo 插件 插件名称 npm 地址 功能 依赖程度 hexo-renderer-multi-markdown-it 链接 md 文件渲染器，压缩 css/js/html 必需 hexo-autoprefixer 链接 给生成的 css 文件们添加浏览器前缀 必需 hexo-algoliasearch 链接 站内搜索功能 搜索按钮失灵 hexo-symbols-count-time 链接 文章或站点字数及阅读时间统计 统计没有 hexo-feed 链接 生成 Feed 文件 Feed 文件没有 没有正确安装以上插件的话，本主题会报错 or 无法正确显示 or 部分功能失效。 hexo-renderer-multi-markdown-it 请注意升级到最新版 安装完以上插件后，修改站点配置文件，加入相关配置。 # multi-markdown-it 安装与配置 # 安装 安装前，记得务必卸载掉默认的 hexo-renderer-marked ，以及别的 markdown 文件渲染器。 123npm un hexo-renderer-marked --save# 或者yarn remove hexo-renderer-marked 安装 123npm i hexo-renderer-multi-markdown-it --save# 或者yarn add hexo-renderer-multi-markdown-it 如果安装缓慢，或者失败 如报错 1ERROR: Failed to download Chromium r515411! Set &quot;PUPPETEER_SKIP_CHROMIUM_DOWNLOAD&quot; env variable to skip download. 因为有一步需要下载 puppeteer 里的 Chromium 内核，基于天朝内部网络现状，这一步能不能成功要靠科学和运气，所以为了避免安装失败，需要加上 --ignore-scripts 跳过 Chromium 内核的下载。 123npm i hexo-renderer-multi-markdown-it --save --ignore-scripts# 或者yarn add hexo-renderer-multi-markdown-it --ignore-scripts puppeteer 主要是用来渲染 mermaid 流程图，只要文章中不使用 mermaid 就没有任何问题，如果要使用 mermaid 建议还是想办法完全安装。 # 配置 加入 markdown 配置，用来渲染 md 文件 1234567891011121314151617181920212223242526272829303132markdown: render: # 渲染器设置 html: false # 过滤 HTML 标签 xhtmlOut: true # 使用 &#x27;/&#x27; 来闭合单标签 （比如 &lt;br /&gt;）。 breaks: true # 转换段落里的 &#x27;\\n&#x27; 到 &lt;br&gt;。 linkify: true # 将类似 URL 的文本自动转换为链接。 typographer: quotes: &#x27;“”‘’&#x27; plugins: # markdown-it插件设置 - plugin: name: markdown-it-toc-and-anchor enable: true options: # 文章目录以及锚点应用的class名称，shoka主题必须设置成这样 tocClassName: &#x27;toc&#x27; anchorClassName: &#x27;anchor&#x27; - plugin: name: markdown-it-multimd-table enable: true options: multiline: true rowspan: true headerless: true - plugin: name: ./markdown-it-furigana enable: true options: fallbackParens: &quot;()&quot; - plugin: name: ./markdown-it-spoiler enable: true options: title: &quot;你知道得太多了&quot; 加入 minify 配置，压缩 css/js/html 12345678910111213141516171819minify: html: enable: true exclude: # 排除hexo-feed用到的模板文件 - &#x27;**/json.ejs&#x27; - &#x27;**/atom.ejs&#x27; - &#x27;**/rss.ejs&#x27; css: enable: true exclude: - &#x27;**/*.min.css&#x27; js: enable: true mangle: toplevel: true output: compress: exclude: - &#x27;**/*.min.js&#x27; 停用默认代码高亮功能，否则代码块的 mac 样式不能正常显示。 找到 highlight 和 prismjs ，把 enable 改成 false 。 12345highlight: enable: falseprismjs: enable: false # autoprefixer 配置建议 123autoprefixer: exclude: - &#x27;*.min.css&#x27; 缺少这个插件，首页卡片翻转效果在部分浏览器中无法正确显示。 # algolia 配置建议 1234567891011121314algolia: appId: #Your appId apiKey: #Your apiKey adminApiKey: #Your adminApiKey chunkSize: 5000 indexName: #&quot;shoka&quot; fields: - title #必须配置 - path #必须配置 - categories #推荐配置 - content:strip:truncate,0,2000 - gallery - photos - tags # feed 配置建议 12345678910111213141516171819keywords: #站点关键词，用“,”分隔feed: limit: 20 order_by: &quot;-date&quot; tag_dir: false category_dir: false rss: enable: true template: &quot;themes/shoka/layout/_alternate/rss.ejs&quot; output: &quot;rss.xml&quot; atom: enable: true template: &quot;themes/shoka/layout/_alternate/atom.ejs&quot; output: &quot;atom.xml&quot; jsonFeed: enable: true template: &quot;themes/shoka/layout/_alternate/json.ejs&quot; output: &quot;feed.json&quot;","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hexo主题Shoka & Multi-Markdown-It渲染器使用说明","slug":"computer-science/note/theme-shoka-doc","date":"2020-08-13T12:45:48.000Z","updated":"2020-11-19T04:23:39.575Z","comments":true,"path":"2020/08/13/computer-science/note/theme-shoka-doc/","link":"","permalink":"http://example.com/2020/08/13/computer-science/note/theme-shoka-doc/","excerpt":"","text":"跳票 N 久终于更新的简单的使用说明 hexo-theme-shoka ：本博客自用的主题 hexo-renderer-multi-markdown-it：配套的 markdown 渲染器 已经支持 hexo 5。。。本文档和 bug 不定期更新中。 如果有什么功能需求，欢迎留言。 当前版本更新至 0.2.5，更新记录点此 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 # 设计缘由 前几年在 Bear 和 Evernote 上整理了大量笔记，非常喜欢 Bear 默认的 markdown 渲染样式。 后来因为换了安卓手机，用不了 Bear，四处搜寻替代品，没有满意的。 然后阴差阳错知道了 Hexo，又得知 Github 也可以免费建私有仓库了，故再次转移阵地到了自建博客，并部署在 Github Pages。 因为这个博客是用来记笔记的，故起名 书架 。 对应的主题即 Theme.Shoka ，可以说是为了笔记阅读而生的主题。 样式严重参考 Bear，部分代码严重参考 NexT。 Hexo 的默认及常用渲染器均使用 highlight.js 进行代码高亮，而我喜欢 Prism.js ，故重写了一个渲染器配合主题食用。 渲染器取名 multi ，因为集成了很多很多很多 markdown-it 插件，以及压缩静态文件的功能。 （最新版的默认渲染器也支持 Prism.js 了，可喜可贺，但不想用，哈哈哈哈哈哈哈 墙内 Github Pages 访问速度时而感人，所以用了 jsDelivr 加速，主要是因为它可以按需合并依赖文件。 # 快速安装 12# cd your-bloggit clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 打开主题目录，内有 example 文件夹，提供了配置文件的 demo 供参考。 # 安装依赖插件 在应用主题之前，必须至少安装 hexo-renderer-multi-markdown-it 渲染插件 和 hexo-autoprefixer。 插件安装与配置教程戳此 # 应用主题 # 修改站点配置 修改站点配置文件 &lt;root&gt;/_config.yml ，把主题改为 shoka 1theme: shoka # 修改主题配置 主题配置的所有参数在 &lt;root&gt;/themes/shoka/_config.yml 文件中。 为了方便主题升级，请在根目录新建一个 yml 文件，命名为 _config.shoka.yml 。 也就是说，所有主题的自定义配置均保存于 &lt;root&gt;/_config.shoka.yml 文件。 主题的基础配置可以参考这里 界面显示相关的配置参考这里 # 更新记录 标签含义： ❗ 需要手动操作的更新信息 ⚠️ 需要注意的更新信息 🔧 已修复的问题 ⌛ TODO # 0.2.4 👉 0.2.5 💡 避免直接修改主题文件，添加各种自定义： 样式：包括配色、icon、其他自定义样式 图片：包括主题图片、随机图库 🔧 修复一些 BUG # 0.2.3 👉 0.2.4 ⚠️ 评论功能更新 MiniValine 魔改版更新至 beta10，修改过主题默认 _config.yml 的同学，记得更新末尾的 vendors 到最新哦 ❗ 评论相关的配置有更新，配置戳此 主要增加的 Tag 配置，现在可以各种自定义啦 ⚠️ 配置新增 夜间模式 darkmode ，配置戳此 自动定位 auto_scroll ，配置戳此 图床 API 设置 image_server ，配置戳此 ⚠️ 背景音乐功能增强，配置戳此 可以添加多个播放列表 加了一些控制按钮 ⚠️ 增加 media 标签，在文章中插入音频和视频播放列表，方法戳此 ⌛ 视频播放器有待增强（显示分段标签，字幕） 🔧 随机图库支持非渣浪图床的任意图片 🔧 还有许多小 BUG # 0.2.2 👉 0.2.3 ❗ 增加主题文件外自定义语言包的功能，配置戳此 🔧 提高低版本浏览器兼容性 # 0.2.1 👉 0.2.2 ⚠️ 弃用 mediumzoom ，改成 fancybox ，配置戳此 💡 增加语言包： 繁体中文 和 日语 💡 quiz 功能优化，根据语言显示题型标签 🔧 修复评论功能中反复初始化 leancloud-storage 🔧 修复 audio: false 时不能隐藏播放按钮、停止播放 # 0.2 👉 0.2.1 ⚠️ 配置文件添加 loader 参数，配置戳此 💡 二级 list 区别显示 🔧 修复浏览位置定位 BUG 🔧 修复 firework 动画延迟 🔧 优化评论功能 # 0.1.9 👉 0.2 ⚠️ 评论功能大改 弃用不开源的 Valine，改用 MiniValine，并且进行了魔改，项目戳此 主要是大量压缩了代码，弃用一些花里胡哨的功能，又加了一些别的花里胡哨的功能。 为防止泄露用户邮箱、IP 等隐私信息，弃用 QQ 号获取昵称及头像。 ❗ 同时需要手动进行一些迁移，具体步骤戳此 ❗ 评论相关的配置亦有更新，配置戳此 ⚠️ 增加单击页面烟花效果，配置戳此 💡 弃用 Velocity，改用 anime.js，方便未来添加更多花里胡哨的功能严重拖慢页面滑行速度 🔧 新增多枚 icon，包括豆瓣 i-douban 等 🔧 一些显示问题","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"第2周 判断","slug":"computer-science/java/course-1/week-2","date":"2020-04-13T11:12:45.000Z","updated":"2020-11-19T04:23:39.569Z","comments":true,"path":"2020/04/13/computer-science/java/course-1/week-2/","link":"","permalink":"http://example.com/2020/04/13/computer-science/java/course-1/week-2/","excerpt":"","text":":::note info 以下为个人学习笔记和习题整理 课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC https://www.icourse163.org/course/ZJU-1001541001 ::: # 课堂笔记 # 关系运算 六个关系运算符： 运算符 意义 == 相等 != 不相等 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt;= 小于或等于 关系运算结果为 true 或 false 优先级 所有关系运算符的优先级比算术运算低，但比赋值运算高 判断是否相等的 == 和！= 优先级比其他的低 连续的关系运算是从左到右进行的 判断两个浮点数是否相等的方法 1Math.abs(f1-f2)&lt;0.0000001 下列表达式中错误的有？ 5 &gt; 3 == 6 &gt; 4 6 &gt; 5 &gt; 4 a == b == true a == b == 6 a == b &gt; false (a == b) &gt; false true 和 false 不能比较大小 # 判断语句 if else 123456789101112if(x &lt; 0) &#123; ...&#125;else if(x == 0) &#123; ...&#125;else&#123; ...&#125; # 多路分支 switch case 12345678910switch (type)&#123; case 1: case 2: ... break; default: System.out.println(...); break;&#125; 计算 switch 后面的控制表达式以后，程序会跳到相应的 case，但是如果这个 case 内部没有 break，那么在执行完语句后，就会顺序执行到下面的 case，直到遇到 break 或者 switch 结束。 # 小测验 写出以下代码段的执行结果： 12345int num=34, max=30;if ( num &gt;= max*2 ) System.out.println(&quot;zhang&quot;); System.out.println(&quot;huang&quot;);System.out.println(&quot;zhu&quot;); huang zhu 写出以下代码段的执行结果： 12345678910int limit = 100;int num1 = 15;int num2 = 40;if ( limit &lt;= limit)&#123; if ( num1 == num2 ) System.out.println(&quot;lemon&quot;); System.out.println(&quot;lime&quot;);&#125;System.out.println(&quot;grape&quot;); lime grape # 编程题 # 题目 1. 时间换算（5 分） 题目内容 UTC 是世界协调时，BJT 是北京时间，UTC 时间相当于 BJT 减去 8。现在，你的程序要读入一个整数，表示 BJT 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果分小于 10 分，需要保留十位上的 0。如 1124 表示 11 点 24 分，而 905 表示 9 点 5 分，36 表示 0 点 36 分，7 表示 0 点 7 分。 有效的输入范围是 0 到 2359，即你的程序不可能从测试服务器读到 0 到 2359 以外的输入数据。 你的程序要输出这个时间对应的 UTC 时间，输出的格式和输入的相同，即输出一个整数，表示 UTC 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果分小于 10 分，需要保留十位上的 0。 提醒：要小心跨日的换算。 输入格式 一个整数，表示 BJT 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果小时不是 0 而且分小于 10 分，需要保留十位上的 0。 输出格式 一个整数，表示 UTC 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果小时不是 0 而且分小于 10 分，需要保留十位上的 0。 输入样例 933 输出样例 133 # 解题代码 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int bjt = in.nextInt(); int utc = bjt - 800; if(utc &lt; 0) &#123; utc += 2400; // 时为负数，则进行隔日计算 &#125; System.out.println(utc); &#125;&#125; # 题目 2. 信号报告（5 分） 题目内容 无线电台的 RS 制信号报告是由三两个部分组成的： R (Readability) 信号可辨度即清晰度. S (Strength) 信号强度即大小. 其中 R 位于报告第一位，共分 5 级，用 1—5 数字表示. 1—Unreadable 2—Barely readable, occasional words distinguishable 3—Readable with considerable difficulty 4—Readable with practically no difficulty 5—Perfectly readable 报告第二位是 S，共分九个级别，用 1—9 中的一位数字表示 1—Faint signals, barely perceptible 2—Very weak signals 3—Weak signals 4—Fair signals 5—Fairly good signals 6—Good signals 7—Moderately strong signals 8—Strong signals 9—Extremely strong signals 现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到 59，则输出： Extremely strong signals, perfectly readable. 输入格式 一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是 [11,59] 内有效的数字，这个范围外的数字不可能出现在测试数据中。 输出格式 一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。 输入样例 33 输出样例 Weak signals, readable with considerable difficulty. # 解题代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int rs = in.nextInt(); int readability = rs / 10; int strength = rs % 10; switch(strength) &#123; case 1: System.out.print(&quot;Faint signals, barely perceptible&quot;); break; case 2: System.out.print(&quot;Very weak signals&quot;); break; case 3: System.out.print(&quot;Weak signals&quot;); break; case 4: System.out.print(&quot;Fair signals&quot;); break; case 5: System.out.print(&quot;Fairly good signals&quot;); break; case 6: System.out.print(&quot;Good signals&quot;); break; case 7: System.out.print(&quot;Moderately strong signals&quot;); break; case 8: System.out.print(&quot;Strong signals&quot;); break; case 9: System.out.print(&quot;Extremely strong signals&quot;); break; &#125; switch(readability) &#123; case 1: System.out.print(&quot;, unreadable.&quot;); break; case 2: System.out.print(&quot;, barely readable, occasional words distinguishable.&quot;); break; case 3: System.out.print(&quot;, readable with considerable difficulty.&quot;); break; case 4: System.out.print(&quot;, readable with practically no difficulty.&quot;); break; case 5: System.out.print(&quot;, perfectly readable.&quot;); break; &#125; &#125;&#125;","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"http://example.com/categories/computer-science/java/"},{"name":"零基础学Java语言-浙江大学-翁恺","slug":"computer-science/java/course-1","permalink":"http://example.com/categories/computer-science/java/course-1/"}],"tags":[]},{"title":"第1周 计算","slug":"computer-science/java/course-1/week-1","date":"2020-04-12T12:46:25.000Z","updated":"2020-11-19T04:23:39.565Z","comments":true,"path":"2020/04/12/computer-science/java/course-1/week-1/","link":"","permalink":"http://example.com/2020/04/12/computer-science/java/course-1/week-1/","excerpt":"","text":":::note info 以下为个人学习笔记和习题整理 课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC https://www.icourse163.org/course/ZJU-1001541001 ::: # 课堂笔记 # 读输入、字符串输出 scanner12345678910111213import java.util.Scanner;...Scanner in = new Scanner(System.in);// 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。System.out.println(in.nextLine());// 让in这个对象做读入下一行的动作，结果交给System.out这个对象去打印一行。// 字符串的 + 用来连接两个字符串形成更长的字符串。System.out.println(&quot;Hello&quot; + &quot; world.&quot;);System.out.println(&quot;Hello&quot; + 2);System.out.println(&quot;Hello&quot; + 2 + 3);System.out.println(2 + 3 + &quot;Hello&quot;); tips： System.out.println 会换行， System.out.print 则不会换行 出现警告： Resource leak: 'in' is never closed ，可以在函数的最后加入 1in.close();//释放 # 变量 形式：&lt;类型名称&gt; &lt; 变量名称 &gt; = &lt; 初始值 &gt; int price, amount; // 同时定义两个变量 int price = 0; // 定义变量并赋值 int price, amount = 100, age; 类型名称：Java 是一种强类型语言，所有变量在使用前必须定义或声明，所有变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，程序运行过程中也不能改变变量的类型。 变量名称：又称标识符，只能由字母、数字、下划线构成，数字不能出现在第一个位置。此外，Java 的保留字也不能用作标识符。 Java 的保留字列表 abstract do implements protected throws boolean double import public transient break else instanceof return true byte extends int short try case false interface static while catch final long strictfp void char finally native super volatile class float new switch const* for null synchronized continue goto* package this default if private throw 以下哪些标识符是符合规则的？ currency lastName fireplace _last_name xingmin class goto 4ever time-machine Int $12 我是变量 # 常量 final 12final int AMOUNT = 100;// final是一个修饰符，表示这个变量的值一旦初始化，就不能再修改了。 # 变量类型 # 整数 int 1int price = in.nextInt(); 如果用户输入的不是整数，则会报错 java.util.InputMismatchException 。 程序要求读入多个数字时，可以在一行输入，中间用空格分开，也可以多行输入。 每次召唤 in.nextInt() ，它就等待用户输入一个整数。 两个整数的运算结果只能是整数。 在 Java 中， 10 和 10.0 是完全不同的数。 # 浮点数 double 浮点数运算有误差：由于二进制的自身限制，浮点计算需要将十进制先转换为二进制，然后对二进制数进行计算，因此导致误差。 12System.out.println(1.2-1.1);// 结果为 0.09999999999999987 整数类型不能表达有小数部分的数；整数运算速度快，占内存小；日常中整数运算多。 # 赋值运算 # 强制类型转换 浮点数和整数放在一起运算时，Java 会将整数转换成浮点数，然后进行浮点数运算。 强制性转换的优先级高于四则运算。 1234double a = 1.0;double b = 2.0;int i = (int)a/b; //会报错int i = (int)(a/b); //不会报错 # 运算符优先级 单目运算符 + - 优先级最高 结合关系一般自左向右，单目 + - 和赋值 = 自右向左。 123result = a = b = 3 + c;result = 2;result = (result = result * 2) * 6 * (result = 3 + result); # 复合赋值 5 个算术运算符， + - * / % ，可以和赋值运算符 = 结合起来，形成复合赋值运算。注意，两个运算符中间不要有空格。 12345678total += (sum+100)/2;total = total + (sum+100)/2;total * = sum+12;total = total*(sum+12);total /= 12+6;total = total / (12+6); 递增递减运算符 ++ -- ，给变量 + 1 或 - 1 前缀后缀： 123a = 14;t1 = a++; // t1先被赋值为 a 即14， a自加到 15t2 = ++a; // a先自加到 15，t2被赋值为 a 即 15 # 编程题 # 题目 1. 温度转换（5 分） 题目内容 写一个将华氏温度转换成摄氏温度的程序，转换的公式是： °F = (9/5)*°C + 32 其中 C 表示摄氏温度，F 表示华氏温度。 程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。 提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式： (int)x; 其中 x 是要转换的那个浮点数。 注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。 输入格式 一个整数。 输出格式 一个整数。 输入样例 100 输出样例 37 # 解题代码 12345678910111213141516import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); // 获得输入的整数 int fahrenheit = in.nextInt(); // 计算摄氏度 double centigrade = (fahrenheit - 32) / (9 / 5.0); // 将浮点数转换为整数输出 System.out.println((int)centigrade); &#125;&#125;","categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"Java","slug":"computer-science/java","permalink":"http://example.com/categories/computer-science/java/"},{"name":"零基础学Java语言-浙江大学-翁恺","slug":"computer-science/java/course-1","permalink":"http://example.com/categories/computer-science/java/course-1/"}],"tags":[]}],"categories":[{"name":"计算机科学","slug":"computer-science","permalink":"http://example.com/categories/computer-science/"},{"name":"二进制杂谈","slug":"computer-science/note","permalink":"http://example.com/categories/computer-science/note/"},{"name":"Theme Shoka Documentation","slug":"computer-science/note/Theme-Shoka-Documentation","permalink":"http://example.com/categories/computer-science/note/Theme-Shoka-Documentation/"},{"name":"Java","slug":"computer-science/java","permalink":"http://example.com/categories/computer-science/java/"},{"name":"零基础学Java语言-浙江大学-翁恺","slug":"computer-science/java/course-1","permalink":"http://example.com/categories/computer-science/java/course-1/"}],"tags":[{"name":"about","slug":"about","permalink":"http://example.com/tags/about/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}